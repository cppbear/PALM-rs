{
  "name": "regex_syntax::error::<error::Formatter<'e, E> as std::fmt::Display>::fmt",
  "name_with_impl": "regex_syntax::error::{impl#6}::fmt",
  "mod_info": {
    "name": "error",
    "loc": "regex-syntax/src/lib.rs:115:1:115:11"
  },
  "visible": true,
  "loc": "regex-syntax/src/error.rs:103:5:133:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Err/None\n"
      ],
      "input_infer": "pattern: length 1-1000 containing at least one '\\n'; line_number_width: 0-10; multi_line length: 0-100; spans: start.line 1-100, end.line 1-100; span.start.column 0-1000, span.end.column 1-1001; err: any type implementing fmt::Display.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\\nxyz\";",
                "    let line_number_width = 0;",
                "    let aux_span = None;",
                "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                "    let err = \"Example error\";",
                "    ",
                "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(_result.is_err());"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(_result.unwrap_err().to_string(), \"regex parse error:\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.pattern.contains('\\n'));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.span.start.line == 1);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.span.end.column == 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(_result.unwrap_err().to_string(), \"regex parse error:\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.pattern.contains('\\n'));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.span.start.line == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\\ndef\\nxyz\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let err = \"Example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.span.end.column == 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:38\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"line1\\nline2\\nline3\";",
                "    let line_number_width = 5;",
                "    let aux_span = None;",
                "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                "",
                "    let err = \"Another example error\";",
                "    ",
                "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                "    let mut spans = Vec::new();",
                "    spans.push(span1);",
                "    spans.push(span2);",
                "    ",
                "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.pattern, \"line1\\nline2\\nline3\");"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.err, \"Another example error\");"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.span.start.line, 1);"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.span.end.column, 5);"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert!(formatter.aux_span.is_none());"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(spans.multi_line.is_empty() == false);"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert_eq!(spans.by_line.len(), 3);"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert_eq!(spans.pattern, \"line1\\nline2\\nline3\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.pattern, \"line1\\nline2\\nline3\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.err, \"Another example error\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.span.start.line, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert_eq!(formatter.span.end.column, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    assert!(formatter.aux_span.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(spans.multi_line.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert_eq!(spans.by_line.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "",
                  "    let err = \"Another example error\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let mut spans = Vec::new();",
                  "    spans.push(span1);",
                  "    spans.push(span2);",
                  "    ",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let line_number_width = 5;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let err = \"Another example error\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert_eq!(spans.pattern, \"line1\\nline2\\nline3\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:326:39\n    |\n326 |     let spans = Spans::from_formatter(&formatter);\n    |                 --------------------- ^^^^^^^^^^ doesn't have a size known at compile-time\n    |                 |\n    |                 required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Spans::<'p>::from_formatter`\n   --> regex-syntax/src/error.rs:166:27\n    |\n166 |     fn from_formatter<'e, E: fmt::Display>(\n    |                           ^ required by the implicit `Sized` requirement on this type parameter in `Spans::<'p>::from_formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n166 |     fn from_formatter<'e, E: fmt::Display + ?Sized>(\n    |                                           ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:326:39\n    |\n326 |     let spans = Spans::from_formatter(&formatter);\n    |                 --------------------- ^^^^^^^^^^ doesn't have a size known at compile-time\n    |                 |\n    |                 required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Spans::<'p>::from_formatter`\n   --> regex-syntax/src/error.rs:166:27\n    |\n166 |     fn from_formatter<'e, E: fmt::Display>(\n    |                           ^ required by the implicit `Sized` requirement on this type parameter in `Spans::<'p>::from_formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n166 |     fn from_formatter<'e, E: fmt::Display + ?Sized>(\n    |                                           ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:36\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:322:74\n    |\n322 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:36\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:323:74\n    |\n323 |     let span2 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:318:38\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n318 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:325:42\n    |\n325 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:326:39\n    |\n326 |     let spans = Spans::from_formatter(&formatter);\n    |                 --------------------- ^^^^^^^^^^ doesn't have a size known at compile-time\n    |                 |\n    |                 required by a bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Spans::<'p>::from_formatter`\n   --> regex-syntax/src/error.rs:166:27\n    |\n166 |     fn from_formatter<'e, E: fmt::Display>(\n    |                           ^ required by the implicit `Sized` requirement on this type parameter in `Spans::<'p>::from_formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n166 |     fn from_formatter<'e, E: fmt::Display + ?Sized>(\n    |                                           ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                "    let line_number_width = 10;",
                "    let aux_span = None;",
                "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                "",
                "    let err = \"Long error message example\";",
                "    ",
                "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(format!(\"{}\", result.err().unwrap()), \"regex parse error:\\n~~~~~~~~~~~~~~~\\naaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\nerror: Long error message example\");"
                ],
                [
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.err().unwrap().to_string(), \"regex parse error:\");"
                ],
                [
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.err().unwrap().kind(), fmt::Error);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "",
                  "    let err = \"Long error message example\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "",
                  "    let err = \"Long error message example\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(format!(\"{}\", result.err().unwrap()), \"regex parse error:\\n~~~~~~~~~~~~~~~\\naaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\nerror: Long error message example\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "",
                  "    let err = \"Long error message example\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.err().unwrap().to_string(), \"regex parse error:\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "",
                  "    let err = \"Long error message example\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"aaaaaa\\nbbbbbb\\ncccccc\\ndddddd\\n\";",
                  "    let line_number_width = 10;",
                  "    let aux_span = None;",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };",
                  "    let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };",
                  "    let err = \"Long error message example\";",
                  "    let formatter = Formatter { pattern, err, span: &span1, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.err().unwrap().kind(), fmt::Error);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:36\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:74\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:36\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:74\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:314:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:321:42\n    |\n321 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:322:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:36\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:74\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:36\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:74\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:314:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:321:42\n    |\n321 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:322:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:36\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:74\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:36\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:74\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:314:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:321:42\n    |\n321 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:322:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:36\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:74\n    |\n318 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:36\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:74\n    |\n319 |     let span2 = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 6 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:313:42\n    |\n313 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:314:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n314 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:314:38\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n314 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:321:42\n    |\n321 |     let formatter = Formatter { pattern, err, span: &span1, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:322:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n322 |     let result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:322:37\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n322 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let pattern = \"\";",
                "    let line_number_width = 0;",
                "    let aux_span = None;",
                "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                "    let err = \"Error with no pattern\";",
                "    ",
                "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(_result.is_err());"
                ],
                [
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(_result.unwrap_err().to_string(), \"regex parse error:\\n~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\");"
                ],
                [
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.pattern.contains('\\n'));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(_result.unwrap_err().to_string(), \"regex parse error:\\n~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    ",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let err = \"Error with no pattern\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(formatter.pattern.contains('\\n'));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:35\n    |\n309 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:73\n    |\n309 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:35\n    |\n317 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:73\n    |\n317 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:312:42\n    |\n312 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:313:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:313:38\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:313:38\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:319:42\n    |\n319 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:320:38\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:320:38\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:35\n    |\n309 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:73\n    |\n309 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:35\n    |\n317 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:73\n    |\n317 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:312:42\n    |\n312 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:313:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:313:38\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:313:38\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:319:42\n    |\n319 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:320:38\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:320:38\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:35\n    |\n309 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:73\n    |\n309 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:35\n    |\n317 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:73\n    |\n317 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:312:42\n    |\n312 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:313:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n313 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:313:38\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:313:38\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n313 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:319:42\n    |\n319 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:320:38\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:320:38\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n320 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a\\nb\\nc\\n\";",
                "    let line_number_width = 2;",
                "    let aux_span = None;",
                "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                "    let err = \"Edge case error\";",
                "",
                "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\\nb\\nc\\n\";",
                  "    let line_number_width = 2;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                  "    let err = \"Edge case error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\\n\";",
                  "    let line_number_width = 2;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                  "    let err = \"Edge case error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(format!(\"{}\", result.unwrap_err()), \"expected error message\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\\n\";",
                  "    let line_number_width = 2;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                  "    let err = \"Edge case error\";",
                  "",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"a\\nb\\nc\\n\";",
                  "    let line_number_width = 2;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                  "    let err = \"Edge case error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\\n\";",
                  "    let line_number_width = 2;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                  "    let err = \"Edge case error\";",
                  "",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let _result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"a\\nb\\nc\\n\";",
                  "    let line_number_width = 2;",
                  "    let aux_span = None;",
                  "    let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };",
                  "    let err = \"Edge case error\";",
                  "    let formatter = Formatter { pattern, err, span: &span, aux_span };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(format!(\"{}\", result.unwrap_err()), \"expected error message\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:37\n    |\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:37\n    |\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:35\n    |\n316 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:73\n    |\n316 |     let span = ast::Span { start: Position { line: 3, column: 0 }, end: Position { line: 3, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:311:42\n    |\n311 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:29\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                             ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                   ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:312:38\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n312 |     let _result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:318:42\n    |\n318 |     let formatter = Formatter { pattern, err, span: &span, aux_span };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:319:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let result = Box::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let result = Arc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n319 |     let result = Rc::new(formatter).fmt(&mut std::fmt::Formatter::new());\n    |                  ++++++++         +\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:319:37\n    |\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:319:37\n    |\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n319 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0277, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Err/None\n"
      ],
      "input_infer": "self.pattern: [1, 100], line_number_width: [1, 10], spans.multi_line: [1, 50]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\\nghi\";",
                "    let error_message = \"Invalid syntax\";",
                "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                "    ",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "    ",
                "    let mut output = String::new();",
                "    let _ = write!(&mut output, \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"~\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"abc\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"def\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"ghi\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"error: Invalid syntax\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"on line 1 (column 0) through line 3 (column 2)\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"~\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"abc\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"def\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"ghi\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"error: Invalid syntax\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"Invalid syntax\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"on line 1 (column 0) through line 3 (column 2)\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\";",
                "    let error_message = \"Unexpected token\";",
                "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                "    ",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut output = String::new();",
                "    let _ = write!(&mut output, \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"on line 1 (column 0) through line 1 (column 2)\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"error: Unexpected token\"));"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.lines().count() > 2);"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.lines().nth(1).unwrap(), &repeat_char('~', 79));"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.lines().last().unwrap(), \"error: Unexpected token\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"on line 1 (column 0) through line 1 (column 2)\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"error: Unexpected token\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.lines().count() > 2);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.lines().nth(1).unwrap(), &repeat_char('~', 79));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\";",
                  "    let error_message = \"Unexpected token\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.lines().last().unwrap(), \"error: Unexpected token\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:35\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:320:73\n    |\n320 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:317:20\n    |\n317 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:25\n    |\n323 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"first line\\nsecond line\\nthird line\";",
                "    let error_message = \"Too many captures\";",
                "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                "",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "",
                "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                "    let mut spans = Spans {",
                "        pattern,",
                "        line_number_width: 5,",
                "        by_line: vec![vec![span], vec![multi_line_span]],",
                "        multi_line: vec![span],",
                "    };",
                "",
                "    spans.add(multi_line_span);",
                "",
                "    let mut output = String::new();",
                "    let _ = write!(&mut output, \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.is_ok());"
                ],
                [
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.is_err());"
                ],
                [
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"on line 1 (column 4) through line 1 (column 9)\"));"
                ],
                [
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"error: Too many captures\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 5,",
                  "        by_line: vec![vec![span], vec![multi_line_span]],",
                  "        multi_line: vec![span],",
                  "    };",
                  "",
                  "    spans.add(multi_line_span);",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 5,",
                  "        by_line: vec![vec![span], vec![multi_line_span]],",
                  "        multi_line: vec![span],",
                  "    };",
                  "",
                  "    spans.add(multi_line_span);",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 5,",
                  "        by_line: vec![vec![span], vec![multi_line_span]],",
                  "        multi_line: vec![span],",
                  "    };",
                  "",
                  "    spans.add(multi_line_span);",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 5,",
                  "        by_line: vec![vec![span], vec![multi_line_span]],",
                  "        multi_line: vec![span],",
                  "    };",
                  "",
                  "    spans.add(multi_line_span);",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"on line 1 (column 4) through line 1 (column 9)\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 5,",
                  "        by_line: vec![vec![span], vec![multi_line_span]],",
                  "        multi_line: vec![span],",
                  "    };",
                  "",
                  "    spans.add(multi_line_span);",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"first line\\nsecond line\\nthird line\";",
                  "    let error_message = \"Too many captures\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };",
                  "    let mut spans = Spans { pattern, line_number_width: 5, by_line: vec![vec![span], vec![multi_line_span]], multi_line: vec![span] };",
                  "    let _ = spans.add(multi_line_span);",
                  "    let output = write!(&mut output, \"{}\", formatter);",
                  "    assert!(output.contains(\"error: Too many captures\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:46\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:84\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:35\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:73\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:46\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:84\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:46\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:84\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:35\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:73\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:46\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:84\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:46\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:84\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:35\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:73\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:46\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:84\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:46\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:84\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:35\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:73\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:46\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:84\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:46\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:84\n    |\n316 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:35\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:73\n    |\n330 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 11 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:46\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:84\n    |\n332 |     let multi_line_span = ast::Span { start: Position { line: 1, column: 4 }, end: Position { line: 1, column: 10 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:20\n    |\n327 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:335:25\n    |\n335 |     let output = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let pattern = \"a\\nb\\n\";",
                "    let error_message = \"Panic condition met!\";",
                "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                "",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut output = String::new();",
                "    let _ = write!(&mut output, \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(result.is_err(), true);"
                ],
                [
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);"
                ],
                [
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.contains(\"error: Panic condition met!\"), true);"
                ],
                [
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.lines().count() > 2, true);"
                ],
                [
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.contains(\"~\"), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(result.is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.contains(\"error: Panic condition met!\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.lines().count() > 2, true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = write!(&mut output, \"{}\", formatter);",
                  "    let pattern = \"a\\nb\\n\";",
                  "    let error_message = \"Panic condition met!\";",
                  "    let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = write!(&mut output, \"{}\", formatter);",
                  "    assert_eq!(output.contains(\"~\"), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:35\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:73\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:35\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:73\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:35\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:73\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:35\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:73\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:35\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:321:73\n    |\n321 |     let span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:318:20\n    |\n318 |     let _ = write!(&mut output, \"{}\", formatter);\n    |                    ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nerror[E0599]: cannot write into `&mut String`\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:25\n    |\n324 |     let result = write!(&mut output, \"{}\", formatter);\n    |                         ^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Err/None\n"
      ],
      "input_infer": "pattern: \"abc\\ndef\\n\", line_number_width: 1, by_line: [[0, 1], [2]], multi_line: [[0, 4]]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyError;",
                "    impl fmt::Display for DummyError {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"dummy error\")",
                "        }",
                "    }",
                "",
                "    let pattern = \"abc\\ndef\\n\";",
                "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 1,",
                "        by_line: vec![vec![span1], vec![span2]],",
                "        multi_line: vec![multi_line_span],",
                "    };",
                "    ",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &DummyError,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut output = Vec::new();",
                "    let result = formatter.fmt(&mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"regex parse error:\")));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"~\")));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"dummy error\")));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"on line 0 (column 3) through line 1 (column 0)\")));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"abc\")));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"def\")));"
                ],
                [
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"~\")));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"regex parse error:\")));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"~\")));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"dummy error\")));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"on line 0 (column 3) through line 1 (column 0)\")));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"abc\")));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"def\")));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyError;",
                  "    impl fmt::Display for DummyError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"dummy error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "    ",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &DummyError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"abc\\ndef\\n\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_line_span],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &DummyError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(output.iter().any(|s| s.contains(\"~\")));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"regex parse error:\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"regex parse error:\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"~\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"~\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"dummy error\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"dummy error\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"on line 0 (column 3) through line 1 (column 0)\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"on line 0 (column 3) through line 1 (column 0)\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"abc\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"abc\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"def\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"def\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:46\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:84\n    |\n315 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:36\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:74\n    |\n334 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:36\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:335:74\n    |\n335 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:46\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:336:84\n    |\n336 |     let multi_line_span = ast::Span { start: Position { line: 0, column: 3 }, end: Position { line: 1, column: 0 } };\n    |                                                                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:332:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n332 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, DummyError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, DummyError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0282]: type annotations needed for `&_`\n   --> regex-syntax/src/error.rs:349:32\n    |\n349 |     assert!(output.iter().any(|s| s.contains(\"~\")));\n    |                                ^    -------- type must be known at this point\n    |\nhelp: consider giving this closure parameter an explicit type, where the type for type parameter `T` is specified\n    |\n349 |     assert!(output.iter().any(|s: &T| s.contains(\"~\")));\n    |                                 ++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0282, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0282`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Err/None\n"
      ],
      "input_infer": "pattern: \"a\\nb\\nc\"; line_number_width: 1; by_line: vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } }], vec![Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } }], vec![Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } }]]; multi_line: vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } }]; aux_span: None; err: \"Test Error\"\n",
      "answers": [
        {
          "uses": [
            "use std::fmt::Write;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct TestError;",
                "    impl fmt::Display for TestError {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"Test Error\")",
                "        }",
                "    }",
                "",
                "    let pattern = \"a\\nb\\nc\";",
                "    let err = TestError;",
                "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                "    ",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 1,",
                "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                "        multi_line: vec![multi_line_span],",
                "    };",
                "",
                "    let span = ast::Span; // This would have the relevant context from your ast module",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &err,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut output = String::new();",
                "    let _ = formatter.fmt(&mut output);",
                "    // We don't assert anything here as per the guidelines",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"~\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.lines().count() > 3);"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"error: Test Error\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"on line 0 (column 0) through line 2 (column 0)\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.matches('\\n').count() == 2);"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"a\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"b\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"c\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"~\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.lines().count() > 3);",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"error: Test Error\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"on line 0 (column 0) through line 2 (column 0)\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.matches('\\n').count() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"a\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"b\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    assert!(output.contains(\"c\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_55::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_56::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_57::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_58::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_59::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_60::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_61::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_62::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 1 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_63::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::fmt::Write;",
                "",
                "    struct TestError;",
                "    impl fmt::Display for TestError {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"Test Error\")",
                "        }",
                "    }",
                "",
                "    let pattern = \"line1\\nline2\\nline3\";",
                "    let err = TestError;",
                "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                "    ",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 1,",
                "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                "        multi_line: vec![multi_line_span],",
                "    };",
                "",
                "    let span = ast::Span; // This would have the relevant context from your ast module",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &err,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut output = String::new();",
                "    let _ = formatter.fmt(&mut output);",
                "    // We don't assert anything here as per the guidelines",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(formatter.fmt(&mut output).is_ok());"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"Test Error\"));"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"line1\"));"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"line2\"));"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"line3\"));"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"on line 0 (column 0) through line 2 (column 4)\"));"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(format_args!{\"~\"} * 79).to_string() == output.lines().nth(1).unwrap();"
                ],
                [
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.lines().last().unwrap().starts_with(\"error: \"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(formatter.fmt(&mut output).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"Test Error\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"line1\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"line2\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"line3\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.contains(\"on line 0 (column 0) through line 2 (column 4)\"));",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(format_args!{\"~\"} * 79).to_string() == output.lines().nth(1).unwrap();",
                  "}"
                ],
                [
                  "{",
                  "    use std::fmt::Write;",
                  "",
                  "    struct TestError;",
                  "    impl fmt::Display for TestError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"Test Error\")",
                  "        }",
                  "    }",
                  "",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    ",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_line_span],",
                  "    };",
                  "",
                  "    let span = ast::Span; // This would have the relevant context from your ast module",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &err,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let _ = formatter.fmt(&mut output);",
                  "    // We don't assert anything here as per the guidelines",
                  "    let pattern = \"line1\\nline2\\nline3\";",
                  "    let err = TestError;",
                  "    let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };",
                  "    let spans = Spans { pattern, line_number_width: 1, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_line_span], };",
                  "    let span = ast::Span;",
                  "    let formatter = Formatter { pattern, err: &err, span: &span, aux_span: None, };",
                  "    let mut output = String::new();",
                  "    assert!(output.lines().last().unwrap().starts_with(\"error: \"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_64::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:349:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n349 |     assert!(formatter.fmt(&mut output).is_ok());\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_64::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_65::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_66::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_67::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_68::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_69::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_70::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_71::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0369]: cannot multiply `Arguments<'_>` by `{integer}`\n   --> regex-syntax/src/error.rs:349:31\n    |\n349 |     assert!(format_args!{\"~\"} * 79).to_string() == output.lines().nth(1).unwrap();\n    |             ----------------- ^ -- {integer}\n    |             |\n    |             Arguments<'_>\n    |\nnote: the foreign item type `Arguments<'_>` doesn't implement `Mul<{integer}>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:323:1\n    |\n    = note: not implement `Mul<{integer}>`\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:316:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n316 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:69\n    |\n316 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:317:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n317 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:31\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:317:69\n    |\n317 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:318:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n318 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:31\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:318:69\n    |\n318 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:319:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n319 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:41\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:319:79\n    |\n319 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:328:16\n    |\n328 |       let span = ast::Span; // This would have the relevant context from your ast module\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:341:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n341 |     let span1 = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:31\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:341:69\n    |\n341 |     let span1 = Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:342:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n342 |     let span2 = Spans { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:31\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:342:69\n    |\n342 |     let span2 = Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:343:17\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n343 |     let span3 = Spans { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                 ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:31\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:343:69\n    |\n343 |     let span3 = Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:344:27\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n344 |     let multi_line_span = Spans { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                           ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:41\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:344:79\n    |\n344 |     let multi_line_span = Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found struct `ast::Span`\n   --> regex-syntax/src/error.rs:346:16\n    |\n346 |       let span = ast::Span;\n    |                  ^^^^^^^^^ help: use struct literal syntax instead: `ast::Span { start: val, end: val }`\n    |\n   ::: regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | / pub struct Span {\n334 | |     /// The start byte offset.\n335 | |     pub start: Position,\n336 | |     /// The end byte offset.\n337 | |     pub end: Position,\n338 | | }\n    | |_- `ast::Span` defined here\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:337:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n337 |     let _ = formatter.fmt(&mut output);\n    |                       ^^^ method not found in `Formatter<'_, TestError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, llmtests::test_fmt_72::TestError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: unused import: `std::fmt::Write`\n   --> regex-syntax/src/error.rs:305:9\n    |\n305 |     use std::fmt::Write;\n    |         ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: spans.multi_line.is_empty() is true\n",
        "// constraint: write!(f, \"error: {}\", self.err)? is Err/None\n"
      ],
      "input_infer": "self.pattern.length: 1-100, self.err.length: 1-50, spans.multi_line.length: 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"some\\nregex\\npattern\";",
                "    let error_message = \"mock error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                "    ",
                "    let mut output = Vec::new();",
                "    let result = formatter.fmt(&mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert_eq!(result, Err(fmt::Error));"
                ],
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"regex parse error:\\n\"[..]));"
                ],
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));"
                ],
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"some\\nregex\\npattern\\n\"[..]));"
                ],
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));"
                ],
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"error: mock error\"[..]));"
                ],
                [
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.len() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert_eq!(result, Err(fmt::Error));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"regex parse error:\\n\"[..]));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"some\\nregex\\npattern\\n\"[..]));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.contains(&b\"error: mock error\"[..]));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"some\\nregex\\npattern\";",
                  "    let error_message = \"mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(output.len() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(output.contains(&b\"regex parse error:\\n\"[..]));\n    |                    ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `core::slice::<impl [T]>::contains`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/slice/mod.rs:2520:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:13\n    |\n316 |     assert!(output.contains(&b\"regex parse error:\\n\"[..]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`, which is required by `Vec<_>: Deref`\n    = note: required for `Vec<[u8]>` to implement `Deref`\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `Vec::<T>::new`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:422:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by an implicit `Sized` bound in `Vec`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:398:1\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));\n    |                    ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `core::slice::<impl [T]>::contains`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/slice/mod.rs:2520:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:13\n    |\n316 |     assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`, which is required by `Vec<_>: Deref`\n    = note: required for `Vec<[u8]>` to implement `Deref`\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `Vec::<T>::new`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:422:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by an implicit `Sized` bound in `Vec`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:398:1\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(output.contains(&b\"some\\nregex\\npattern\\n\"[..]));\n    |                    ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `core::slice::<impl [T]>::contains`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/slice/mod.rs:2520:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:13\n    |\n316 |     assert!(output.contains(&b\"some\\nregex\\npattern\\n\"[..]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`, which is required by `Vec<_>: Deref`\n    = note: required for `Vec<[u8]>` to implement `Deref`\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `Vec::<T>::new`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:422:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by an implicit `Sized` bound in `Vec`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:398:1\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));\n    |                    ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `core::slice::<impl [T]>::contains`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/slice/mod.rs:2520:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:13\n    |\n316 |     assert!(output.contains(&b\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\"[..]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`, which is required by `Vec<_>: Deref`\n    = note: required for `Vec<[u8]>` to implement `Deref`\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `Vec::<T>::new`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:422:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by an implicit `Sized` bound in `Vec`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:398:1\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(output.contains(&b\"error: mock error\"[..]));\n    |                    ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `core::slice::<impl [T]>::contains`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/slice/mod.rs:2520:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:316:13\n    |\n316 |     assert!(output.contains(&b\"error: mock error\"[..]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`, which is required by `Vec<_>: Deref`\n    = note: required for `Vec<[u8]>` to implement `Deref`\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by a bound in `Vec::<T>::new`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:422:5\n\nerror[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:310:22\n    |\n310 |     let mut output = Vec::new();\n    |                      ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[u8]`\nnote: required by an implicit `Sized` bound in `Vec`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:398:1\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 3, column: 8 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                "    let error_message = \"another mock error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                "    ",
                "    let mut output = Vec::new();",
                "    let result = formatter.fmt(&mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert_eq!(output, expected_output_variable);  // expected_output_variable should be defined with what the output is expected to be"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(writeln!(f, \"regex parse error:\").is_ok());"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(write!(f, \"{}\", notated).is_ok());"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(spans.multi_line.is_empty());"
                ],
                [
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(write!(f, \"error: {}\", self.err).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert_eq!(output, expected_output_variable);  // expected_output_variable should be defined with what the output is expected to be",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(writeln!(f, \"regex parse error:\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(write!(f, \"{}\", notated).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(spans.multi_line.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"another\\nregex\\nwith\\ndifferent\\nlines\";",
                  "    let error_message = \"another mock error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    assert!(write!(f, \"error: {}\", self.err).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `expected_output_variable` in this scope\n   --> regex-syntax/src/error.rs:316:24\n    |\n316 |     assert_eq!(output, expected_output_variable);  // expected_output_variable should be defined with what the output is expected to be\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:316:22\n    |\n316 |     assert!(writeln!(f, \"regex parse error:\").is_ok());\n    |                      ^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:316:22\n    |\n316 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `divider` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                               ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(write!(f, \"{}\", notated).is_ok());\n    |                    ^ not found in this scope\n\nerror[E0425]: cannot find value `notated` in this scope\n   --> regex-syntax/src/error.rs:316:29\n    |\n316 |     assert!(write!(f, \"{}\", notated).is_ok());\n    |                             ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:316:22\n    |\n316 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `divider` in this scope\n   --> regex-syntax/src/error.rs:316:31\n    |\n316 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                               ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `spans` in this scope\n   --> regex-syntax/src/error.rs:316:13\n    |\n316 |     assert!(spans.multi_line.is_empty());\n    |             ^^^^^ help: a local variable with a similar name exists: `span`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 5, column: 5 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:316:20\n    |\n316 |     assert!(write!(f, \"error: {}\", self.err).is_err());\n    |                    ^ not found in this scope\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/error.rs:316:36\n    |\n303 | fn test_fmt_87()\n    |    ----------- this function can't have a `self` parameter\n...\n316 |     assert!(write!(f, \"error: {}\", self.err).is_err());\n    |                                    ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0424, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                "    let error_message = \"error exceeding length\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                "    ",
                "    let mut output = Vec::new();",
                "    let result = formatter.fmt(&mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"regex parse error:\"), true);"
                ],
                [
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"eror: error exceeding length\"), true);"
                ],
                [
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"~\"), true);"
                ],
                [
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"valid regex\"), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"regex parse error:\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"eror: error exceeding length\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"~\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"a\".repeat(101) + \"\\nvalid regex\";",
                  "    let error_message = \"error exceeding length\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output).contains(\"valid regex\"), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:33\n    |\n309 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:316:33\n    |\n316 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n316 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:33\n    |\n309 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:316:33\n    |\n316 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n316 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:33\n    |\n309 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:316:33\n    |\n316 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n316 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:33\n    |\n309 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:316:33\n    |\n316 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n316 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:35\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:73\n    |\n308 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 102 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:33\n    |\n309 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:316:33\n    |\n316 |     let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n316 |     let formatter = Formatter { pattern: &pattern, err: &error_message, span: &span, aux_span: None };\n    |                                 ++++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"simple\\npattern\";",
                "    let error_message = \"err\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                "    ",
                "    let mut output = Vec::new();",
                "    let result = formatter.fmt(&mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(output, b\"regex parse error:\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");"
                ],
                [
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output), \"regex parse error:\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\nerror: err\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(output, b\"regex parse error:\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"simple\\npattern\";",
                  "    let error_message = \"err\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(String::from_utf8_lossy(&output), \"regex parse error:\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\nerror: err\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 2, column: 7 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"\\n\";",
                "    let error_message = \"edge case error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                "    ",
                "    let mut output = Vec::new();",
                "    let result = formatter.fmt(&mut output);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(output.len(), 0);"
                ],
                [
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(String::from_utf8_lossy(&output).contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(String::from_utf8_lossy(&output).contains(\"error: edge case error\"));"
                ],
                [
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(String::from_utf8_lossy(&output).contains(\"~\".repeat(79)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(output.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(String::from_utf8_lossy(&output).contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(String::from_utf8_lossy(&output).contains(\"error: edge case error\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    ",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    let pattern = \"\\n\";",
                  "    let error_message = \"edge case error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = Vec::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(String::from_utf8_lossy(&output).contains(\"~\".repeat(79)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:317:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n317 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0277]: the trait bound `String: Pattern<'_>` is not satisfied\n   --> regex-syntax/src/error.rs:318:55\n    |\n318 |     assert!(String::from_utf8_lossy(&output).contains(\"~\".repeat(79)));\n    |                                              -------- ^^^^^^^^^^^^^^ the trait `Pattern<'_>` is not implemented for `String`\n    |                                              |\n    |                                              required by a bound introduced by this call\n    |\n    = note: required for `String` to implement `Pattern<'_>`\nnote: required by a bound in `core::str::<impl str>::contains`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/str/mod.rs:1140:5\nhelp: consider borrowing here\n    |\n318 |     assert!(String::from_utf8_lossy(&output).contains(&\"~\".repeat(79)));\n    |                                                       +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: spans.multi_line.is_empty() is false\n",
        "// constraint: span in &spans.multi_line is true\n",
        "// constraint: span in &spans.multi_line is false\n",
        "// constraint: writeln!(f, \"{}\", notes.join(\"\\n\"))? is Ok/Some\n",
        "// constraint: write!(f, \"error: {}\", self.err)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "pattern: length 1 to 1000 characters, contains at least 1 newline, line_number_width: 1 to 10, spans.by_line: at least 1 line with non-empty spans, spans.multi_line: at least 1 span with different start/end line numbers, spans.multi_line: contains elements with overlapping and non-overlapping span cases, self.err: length 1 to 100 characters\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                "    let line_number_width = 5; // Valid line number width",
                "    let stderr = \"Some error occurred\"; // Error message",
                "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                "",
                "    let formatter = Formatter {",
                "        pattern: pattern,",
                "        err: &stderr,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut spans = Spans {",
                "        pattern: pattern,",
                "        line_number_width: line_number_width,",
                "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                "        multi_line: vec![multi_span],",
                "    };",
                "",
                "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(formatter.pattern.contains('\\n'), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(spans.line_number_width, 5);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(spans.multi_line.is_empty(), false);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(span_in_multiline(&spans.multi_line, span1), false);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(span_in_multiline(&spans.multi_line, multi_span), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(formatter.pattern.contains('\\n'), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(spans.line_number_width, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(spans.multi_line.is_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(span_in_multiline(&spans.multi_line, span1), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(span_in_multiline(&spans.multi_line, multi_span), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\"; // Length is within 1 to 1000 characters and contains newlines",
                  "    let line_number_width = 5; // Valid line number width",
                  "    let stderr = \"Some error occurred\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2], vec![span3]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let line_number_width = 5;",
                  "    let stderr = \"Some error occurred\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };",
                  "    let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let mut spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1], vec![span2], vec![span3]], multi_line: vec![multi_span] };",
                  "    let result = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0425]: cannot find function `span_in_multiline` in this scope\n   --> regex-syntax/src/error.rs:338:16\n    |\n338 |     assert_eq!(span_in_multiline(&spans.multi_line, span1), false);\n    |                ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0425]: cannot find function `span_in_multiline` in this scope\n   --> regex-syntax/src/error.rs:338:16\n    |\n338 |     assert_eq!(span_in_multiline(&spans.multi_line, multi_span), true);\n    |                ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:36\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:74\n    |\n310 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:41\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:79\n    |\n311 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:36\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:74\n    |\n332 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:36\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:333:74\n    |\n333 |     let span3 = ast::Span { start: Position { line: 2, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:41\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:334:79\n    |\n334 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 2, column: 3 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:327:22\n    |\n327 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:337:27\n    |\n337 |     let result = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                           ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                "    let line_number_width = 3; // Valid line number width",
                "    let stderr = \"Another error\"; // Error message",
                "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                "",
                "    let formatter = Formatter {",
                "        pattern: pattern,",
                "        err: &stderr,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut spans = Spans {",
                "        pattern: pattern,",
                "        line_number_width: line_number_width,",
                "        by_line: vec![vec![span1], vec![span2]],",
                "        multi_line: vec![multi_span],",
                "    };",
                "",
                "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(self.pattern.contains('\\n'));"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"regex parse error:\").is_ok());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(write!(f, \"{}\", notated).is_ok());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(!spans.multi_line.is_empty());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(span in &spans.multi_line);"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(span in &spans.multi_line);"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_ok());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(write!(f, \"error: {}\", self.err).is_ok());"
                ],
                [
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(self.pattern.contains('\\n'));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"regex parse error:\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(write!(f, \"{}\", notated).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(!spans.multi_line.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(span in &spans.multi_line);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(span in &spans.multi_line);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert!(write!(f, \"error: {}\", self.err).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\"; // Contains newlines",
                  "    let line_number_width = 3; // Valid line number width",
                  "    let stderr = \"Another error\"; // Error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: vec![multi_span],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"hello\\nworld\\nrust\\nlanguage\";",
                  "    let line_number_width = 3;",
                  "    let stderr = \"Another error\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };",
                  "    let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: vec![multi_span],",
                  "    };",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/error.rs:345:13\n    |\n303 | fn test_fmt_111()\n    |    ------------ this function can't have a `self` parameter\n...\n345 |     assert!(self.pattern.contains('\\n'));\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0424, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:345:22\n    |\n345 |     assert!(writeln!(f, \"regex parse error:\").is_ok());\n    |                      ^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:345:22\n    |\n345 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `divider` in this scope\n   --> regex-syntax/src/error.rs:345:31\n    |\n345 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                               ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:345:20\n    |\n345 |     assert!(write!(f, \"{}\", notated).is_ok());\n    |                    ^ not found in this scope\n\nerror[E0425]: cannot find value `notated` in this scope\n   --> regex-syntax/src/error.rs:345:29\n    |\n345 |     assert!(write!(f, \"{}\", notated).is_ok());\n    |                             ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:345:22\n    |\n345 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `divider` in this scope\n   --> regex-syntax/src/error.rs:345:31\n    |\n345 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                               ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found keyword `in`\n   --> regex-syntax/src/error.rs:345:18\n    |\n345 |     assert!(span in &spans.multi_line);\n    |                  ^^ expected one of 7 possible tokens\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found keyword `in`\n   --> regex-syntax/src/error.rs:345:18\n    |\n345 |     assert!(span in &spans.multi_line);\n    |                  ^^ expected one of 7 possible tokens\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:345:22\n    |\n345 |     assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `notes` in this scope\n   --> regex-syntax/src/error.rs:345:31\n    |\n345 |     assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_ok());\n    |                               ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:345:20\n    |\n345 |     assert!(write!(f, \"error: {}\", self.err).is_ok());\n    |                    ^ not found in this scope\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/error.rs:345:36\n    |\n303 | fn test_fmt_120()\n    |    ------------ this function can't have a `self` parameter\n...\n345 |     assert!(write!(f, \"error: {}\", self.err).is_ok());\n    |                                    ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0424, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:36\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:309:74\n    |\n309 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:41\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:79\n    |\n310 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:36\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:74\n    |\n330 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:36\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:331:74\n    |\n331 |     let span2 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:41\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:332:79\n    |\n332 |     let multi_span = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0423]: expected value, found module `result`\n   --> regex-syntax/src/error.rs:345:16\n    |\n345 |     assert_eq!(result, Ok(()));\n    |                ^^^^^^ not a value\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:326:22\n    |\n326 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0423, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"single line\"; // No newline",
                "    let line_number_width = 0; // No line numbers",
                "    let stderr = \"Single line error\"; // Error message",
                "   ",
                "    let formatter = Formatter {",
                "        pattern: pattern,",
                "        err: &stderr,",
                "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut spans = Spans {",
                "        pattern: pattern,",
                "        line_number_width: line_number_width,",
                "        by_line: vec![vec![]],",
                "        multi_line: vec![],",
                "    };",
                "",
                "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(self.pattern.contains('\\n') == false);"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(spans.multi_line.is_empty() == true);"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(write!(std::io::stdout(), \"error: {}\", self.err).is_ok());"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(Ok(()), _);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(self.pattern.contains('\\n') == false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(spans.multi_line.is_empty() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(write!(std::io::stdout(), \"error: {}\", self.err).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\"; // No newline",
                  "    let line_number_width = 0; // No line numbers",
                  "    let stderr = \"Single line error\"; // Error message",
                  "   ",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"single line\";",
                  "    let line_number_width = 0;",
                  "    let stderr = \"Single line error\";",
                  "    let formatter = Formatter {",
                  "    pattern: pattern,",
                  "    err: &stderr,",
                  "    span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },",
                  "    aux_span: None,",
                  "    };",
                  "    let mut spans = Spans {",
                  "    pattern: pattern,",
                  "    line_number_width: line_number_width,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(Ok(()), _);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/error.rs:339:13\n    |\n303 | fn test_fmt_122()\n    |    ------------ this function can't have a `self` parameter\n...\n339 |     assert!(self.pattern.contains('\\n') == false);\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0424, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:339:22\n    |\n339 |     assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:339:22\n    |\n339 |     assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:339:22\n    |\n339 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:339:22\n    |\n339 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:339:20\n    |\n339 |     assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:339:20\n    |\n339 |     assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:339:22\n    |\n339 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:339:22\n    |\n339 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/error.rs:339:52\n    |\n303 | fn test_fmt_128()\n    |    ------------ this function can't have a `self` parameter\n...\n339 |     assert!(write!(std::io::stdout(), \"error: {}\", self.err).is_ok());\n    |                                                    ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:339:20\n    |\n339 |     assert!(write!(std::io::stdout(), \"error: {}\", self.err).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:339:20\n    |\n339 |     assert!(write!(std::io::stdout(), \"error: {}\", self.err).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0424, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: no rules expected the token `_`\n   --> regex-syntax/src/error.rs:339:24\n    |\n339 |     assert_eq!(Ok(()), _);\n    |                        ^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$right:expr`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/macros/mod.rs:37:18\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:35\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:73\n    |\n312 |         span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:69\n    |\n330 |     span: &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: pattern.len() } },\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:323:22\n    |\n323 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                "    let line_number_width = 2; // Valid line number width",
                "    let stderr = \"\"; // Empty error message",
                "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                "",
                "    let formatter = Formatter {",
                "        pattern: pattern,",
                "        err: &stderr,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut spans = Spans {",
                "        pattern: pattern,",
                "        line_number_width: line_number_width,",
                "        by_line: vec![vec![span1]],",
                "        multi_line: vec![span1],",
                "    };",
                "",
                "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(self.pattern.contains('\\n'));"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(!spans.multi_line.is_empty());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(span1 in &spans.multi_line);"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(span1 in &spans.multi_line);"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", notes.join(\"\\n\")).is_ok());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(write!(std::io::stdout(), \"error: {}\", formatter.err).is_ok());"
                ],
                [
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert_eq!(_ , Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(self.pattern.contains('\\n'));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(!spans.multi_line.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(span1 in &spans.multi_line);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(span1 in &spans.multi_line);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(writeln!(std::io::stdout(), \"{}\", notes.join(\"\\n\")).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert!(write!(std::io::stdout(), \"error: {}\", formatter.err).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line one\\nline two\\nline three\"; // Valid pattern with newlines",
                  "    let line_number_width = 2; // Valid line number width",
                  "    let stderr = \"\"; // Empty error message",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "",
                  "    let formatter = Formatter {",
                  "        pattern: pattern,",
                  "        err: &stderr,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut spans = Spans {",
                  "        pattern: pattern,",
                  "        line_number_width: line_number_width,",
                  "        by_line: vec![vec![span1]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "",
                  "    let _ = writeln!(std::io::stdout(), \"{}\", formatter);",
                  "    let pattern = \"line one\\nline two\\nline three\";",
                  "    let line_number_width = 2;",
                  "    let stderr = \"\";",
                  "    let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };",
                  "    let formatter = Formatter { pattern: pattern, err: &stderr, span: &span1, aux_span: None };",
                  "    let spans = Spans { pattern: pattern, line_number_width: line_number_width, by_line: vec![vec![span1]], multi_line: vec![span1] };",
                  "    assert_eq!(_ , Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0424]: expected value, found module `self`\n   --> regex-syntax/src/error.rs:331:13\n    |\n303 | fn test_fmt_130()\n    |    ------------ this function can't have a `self` parameter\n...\n331 |     assert!(self.pattern.contains('\\n'));\n    |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0424, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"regex parse error:\").is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:331:20\n    |\n331 |     assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:331:20\n    |\n331 |     assert!(write!(std::io::stdout(), \"{}\", spans.notate()).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", repeat_char('~', 79)).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found keyword `in`\n   --> regex-syntax/src/error.rs:331:19\n    |\n331 |     assert!(span1 in &spans.multi_line);\n    |                   ^^ expected one of 7 possible tokens\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found keyword `in`\n   --> regex-syntax/src/error.rs:331:19\n    |\n331 |     assert!(span1 in &spans.multi_line);\n    |                   ^^ expected one of 7 possible tokens\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `notes` in this scope\n   --> regex-syntax/src/error.rs:331:47\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", notes.join(\"\\n\")).is_ok());\n    |                                               ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", notes.join(\"\\n\")).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:331:22\n    |\n331 |     assert!(writeln!(std::io::stdout(), \"{}\", notes.join(\"\\n\")).is_ok());\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:331:20\n    |\n331 |     assert!(write!(std::io::stdout(), \"error: {}\", formatter.err).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:331:20\n    |\n331 |     assert!(write!(std::io::stdout(), \"error: {}\", formatter.err).is_ok());\n    |                    ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: no rules expected the token `_`\n   --> regex-syntax/src/error.rs:331:16\n    |\n331 |     assert_eq!(_ , Ok(()));\n    |                ^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$left:expr`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/macros/mod.rs:37:6\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:36\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:74\n    |\n328 |     let span1 = ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 1, column: 5 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: cannot write into `Stdout`\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/io/mod.rs:1806:8\n    |\n    = note: the method is available for `Stdout` here\n    |\nnote: must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\n   --> regex-syntax/src/error.rs:324:22\n    |\n324 |     let _ = writeln!(std::io::stdout(), \"{}\", formatter);\n    |                      ^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::io::Write;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: spans.multi_line.is_empty() is false\n",
        "// constraint: span in &spans.multi_line is false\n",
        "// constraint: writeln!(f, \"{}\", notes.join(\"\\n\"))? is Err/None\n"
      ],
      "input_infer": "pattern: \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\", line_number_width: 2, spans.by_line: [[]], spans.multi_line: [ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } }]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockError;",
                "    impl fmt::Display for MockError {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"mock error\")",
                "        }",
                "    }",
                "    ",
                "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 2,",
                "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                "        multi_line: vec![span1],",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &MockError,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "    ",
                "    let result = formatter.fmt(&mut std::io::stdout());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "    multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &MockError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "    multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &MockError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    assert_eq!(result.unwrap_err().to_string(), \"error: mock error\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "    multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &MockError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "    multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &MockError,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    assert_eq!(result.unwrap_err().to_string(), \"error: mock error\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:329:36\n    |\n329 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:329:74\n    |\n329 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:327:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n327 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:36\n    |\n313 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:313:74\n    |\n313 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:329:36\n    |\n329 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:329:74\n    |\n329 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:327:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n327 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct MockError;",
                "    impl fmt::Display for MockError {",
                "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                "            write!(f, \"mock error\")",
                "        }",
                "    }",
                "    ",
                "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 2,",
                "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                "        multi_line: vec![span1],",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &MockError,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "    ",
                "    let result = formatter.fmt(&mut std::io::stdout());",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(spans.multi_line.is_empty() == false);"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_err());"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"regex parse error:\").is_ok());"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(write!(f, \"{}\", notated).is_ok());"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(spans.multi_line.is_empty() == false);"
                ],
                [
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(span in &spans.multi_line == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(spans.multi_line.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"regex parse error:\").is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(write!(f, \"{}\", notated).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(writeln!(f, \"{}\", divider).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(spans.multi_line.is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    struct MockError;",
                  "    impl fmt::Display for MockError {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"mock error\")",
                  "        }",
                  "    }",
                  "    ",
                  "    let pattern = \"abc\\ndef\\nghi\\njkl\\nmno\\npqr\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![span1],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &MockError,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::io::stdout());",
                  "    let spans = Spans::from_formatter(&formatter);",
                  "    assert!(span in &spans.multi_line == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:330:22\n    |\n330 |     assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_err());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `notes` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     assert!(writeln!(f, \"{}\", notes.join(\"\\n\")).is_err());\n    |                               ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:330:22\n    |\n330 |     assert!(writeln!(f, \"regex parse error:\").is_ok());\n    |                      ^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:330:22\n    |\n330 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `divider` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                               ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:330:20\n    |\n330 |     assert!(write!(f, \"{}\", notated).is_ok());\n    |                    ^ not found in this scope\n\nerror[E0425]: cannot find value `notated` in this scope\n   --> regex-syntax/src/error.rs:330:29\n    |\n330 |     assert!(write!(f, \"{}\", notated).is_ok());\n    |                             ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0425]: cannot find value `f` in this scope\n   --> regex-syntax/src/error.rs:330:22\n    |\n330 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                      ^ not found in this scope\n\nerror[E0425]: cannot find value `divider` in this scope\n   --> regex-syntax/src/error.rs:330:31\n    |\n330 |     assert!(writeln!(f, \"{}\", divider).is_ok());\n    |                               ^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, or an operator, found keyword `in`\n   --> regex-syntax/src/error.rs:330:18\n    |\n330 |     assert!(span in &spans.multi_line == false);\n    |                  ^^ expected one of 7 possible tokens\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span1 = ast::Span { start: Position { line: 1, column: 0 }, end: Position { line: 3, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:328:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n328 |     let result = formatter.fmt(&mut std::io::stdout());\n    |                            ^^^ method not found in `Formatter<'_, MockError>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:753:8\n    |\n    = note: the method is available for `error::Formatter<'_, MockError>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Display` which provides `fmt` is implemented but not in scope; perhaps you want to import it\n    |\n300 +    use std::fmt::Display;\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is true\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: writeln!(f, \"{}\", divider)? is Ok/Some\n",
        "// constraint: spans.multi_line.is_empty() is false\n",
        "// constraint: span in &spans.multi_line is false\n",
        "// constraint: writeln!(f, \"{}\", notes.join(\"\\n\"))? is Ok/Some\n",
        "// constraint: write!(f, \"error: {}\", self.err)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "self.pattern length: 1..=1000, self.err length: 1..=50, spans.multi_line count: 1..=100, span.start.line: 1..=100, span.end.line: 1..=100, span.start.column: 1..=100, span.end.column: 1..=100\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a\\nb\\nc\";",
                "    let error_message = \"syntax error\";",
                "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                "    let multi_line_spans = vec![span_start, span_end];",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 2,",
                "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                "        multi_line: multi_line_spans,",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span_start,",
                "        aux_span: None,",
                "    };",
                "    let mut output = String::new();",
                "    formatter.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"~\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"a\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"b\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"c\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"error: syntax error\"));"
                ],
                [
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"on line 1 (column 1) through line 2 (column 1)\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"~\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"a\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"b\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"c\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"error: syntax error\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\\nb\\nc\";",
                  "    let error_message = \"syntax error\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end], vec![]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(output.contains(\"on line 1 (column 1) through line 2 (column 1)\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                "    let error_message = \"error message\";",
                "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                "    let multi_line_spans = vec![span_start, span_end];",
                "    let spans = Spans {",
                "        pattern: &pattern,",
                "        line_number_width: 2,",
                "        by_line: vec![vec![span_start], vec![span_end]],",
                "        multi_line: multi_line_spans,",
                "    };",
                "    let formatter = Formatter {",
                "        pattern: &pattern,",
                "        err: &error_message,",
                "        span: &span_start,",
                "        aux_span: None,",
                "    };",
                "    let mut output = String::new();",
                "    formatter.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"));"
                ],
                [
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(&pattern));"
                ],
                [
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"on line 1 (column 1) through line 2 (column 1)\"));"
                ],
                [
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"error: error message\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern: &pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern: &pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern: &pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern: &pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern: &pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern: &pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(&pattern));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern: &pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern: &pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"on line 1 (column 1) through line 2 (column 1)\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern: &pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern: &pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);",
                  "    let error_message = \"error message\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern: &pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern: &pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"error: error message\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:305:45\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:324:45\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:305:45\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:324:45\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:305:45\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:324:45\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:305:45\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:324:45\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 2 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:305:45\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n305 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:324:45\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + \"b\".repeat(1000);\n    |                                             ^^^^^^^^^^^^^^^^ expected `&str`, found `String`\n    |\nhelp: consider borrowing here\n    |\n324 |     let pattern = \"a\".repeat(1000) + \"\\n\" + &\"b\".repeat(1000);\n    |                                             +\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:342:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n342 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"line 1\\nline 2\";",
                "    let error_message = \"capture group name duplicate\";",
                "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                "    let multi_line_spans = vec![span_start, span_end];",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 3,",
                "        by_line: vec![vec![span_start], vec![span_end]],",
                "        multi_line: multi_line_spans,",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span_start,",
                "        aux_span: None,",
                "    };",
                "    let mut output = String::new();",
                "    formatter.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 3,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(!spans.multi_line.is_empty());"
                ],
                [
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 3,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    assert_eq!(output, \"regex parse error:\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\nline 1\\nline 2\\non line 1 (column 1) through line 2 (column 4)\\nerror: capture group name duplicate\");"
                ],
                [
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 3,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(formatter.fmt(&mut output).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 3,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 3,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(!spans.multi_line.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 3,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 3,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    assert_eq!(output, \"regex parse error:\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\nline 1\\nline 2\\non line 1 (column 1) through line 2 (column 4)\\nerror: capture group name duplicate\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 3,",
                  "        by_line: vec![vec![span_start], vec![span_end]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span_start,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"line 1\\nline 2\";",
                  "    let error_message = \"capture group name duplicate\";",
                  "    let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };",
                  "    let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };",
                  "    let multi_line_spans = vec![span_start, span_end];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 3,",
                  "    by_line: vec![vec![span_start], vec![span_end]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span_start,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(formatter.fmt(&mut output).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:41\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:79\n    |\n307 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:41\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:79\n    |\n326 |     let span_start = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 5 } };\n    |                                                                               ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:39\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:77\n    |\n327 |     let span_end = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 5 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     assert!(formatter.fmt(&mut output).is_ok());\n    |                       ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\\nghi\";",
                "    let error_message = \"invalid escape\";",
                "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 2,",
                "        by_line: vec![vec![span1], vec![span2]],",
                "        multi_line: multi_line_spans,",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span1,",
                "        aux_span: None,",
                "    };",
                "    let mut output = String::new();",
                "    formatter.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"~\"), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"on line 1 (column 1) through line 1 (column 3)\"), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"on line 2 (column 1) through line 2 (column 3)\"), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"error: invalid escape\"), true);"
                ],
                [
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, /* expected output based on input */);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"~\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"on line 1 (column 1) through line 1 (column 3)\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"on line 2 (column 1) through line 2 (column 3)\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output.contains(\"error: invalid escape\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![span1], vec![span2]],",
                  "        multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span1,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"abc\\ndef\\nghi\";",
                  "    let error_message = \"invalid escape\";",
                  "    let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };",
                  "    let multi_line_spans = vec![span1.clone(), span2.clone()];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 2,",
                  "    by_line: vec![vec![span1], vec![span2]],",
                  "    multi_line: multi_line_spans,",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span1,",
                  "    aux_span: None,",
                  "    };",
                  "    let output = formatter.fmt(&mut output).unwrap();",
                  "    assert_eq!(output, /* expected output based on input */);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:36\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:74\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:36\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:74\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     let output = formatter.fmt(&mut output).unwrap();\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:36\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:74\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:36\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:74\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     let output = formatter.fmt(&mut output).unwrap();\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:36\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:74\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:36\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:74\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     let output = formatter.fmt(&mut output).unwrap();\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:36\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:74\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:36\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:74\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     let output = formatter.fmt(&mut output).unwrap();\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:36\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:74\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:36\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:74\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     let output = formatter.fmt(&mut output).unwrap();\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected end of macro invocation\n   --> regex-syntax/src/error.rs:342:23\n    |\n342 |     assert_eq!(output, /* expected output based on input */);\n    |                       ^ missing tokens in macro arguments\n    |\nnote: while trying to match meta-variable `$right:expr`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/macros/mod.rs:37:18\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:36\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:74\n    |\n308 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:36\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:74\n    |\n326 |     let span1 = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:36\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:74\n    |\n327 |     let span2 = ast::Span { start: Position { line: 2, column: 1 }, end: Position { line: 2, column: 4 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:323:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n323 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:341:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n341 |     let output = formatter.fmt(&mut output).unwrap();\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"single line\";",
                "    let error_message = \"unexpected character\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 0,",
                "        by_line: vec![vec![span]],",
                "        multi_line: vec![],",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "    let mut output = String::new();",
                "    formatter.fmt(&mut output).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"error: unexpected character\"));"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"single line\"));"
                ],
                [
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.lines().count() == 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![span]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![span]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"error: unexpected character\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![span]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.contains(\"single line\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![span]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    let pattern = \"single line\";",
                  "    let error_message = \"unexpected character\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![span]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    let mut output = String::new();",
                  "    formatter.fmt(&mut output).unwrap();",
                  "    assert!(output.lines().count() == 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:35\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:73\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:321:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n321 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:338:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n338 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:35\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:73\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:321:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n321 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:338:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n338 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:35\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:73\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:321:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n321 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:338:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n338 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:35\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:324:73\n    |\n324 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 12 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:321:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n321 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:338:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n338 |     formatter.fmt(&mut output).unwrap();\n    |               ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is false\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Err/None\n"
      ],
      "input_infer": "self.pattern: \"\", \"a\", \"abc\"; f: valid fmt::Formatter; self.err: usize::MIN, 0, 1, usize::MAX;\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"\";",
                "    let err = &0;",
                "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                "    let mut output = String::new();",
                "    let mut f = fmt::Formatter::new(&mut output);",
                "    formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(formatter.fmt(&mut f).is_ok(), true);"
                ],
                [
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);"
                ],
                [
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.contains(\"error: 0\"), true);"
                ],
                [
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.contains(\"\"), true);"
                ],
                [
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.lines().count(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(formatter.fmt(&mut f).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.contains(\"error: 0\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.contains(\"\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = &0;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    assert_eq!(output.lines().count(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, {integer}>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     assert_eq!(formatter.fmt(&mut f).is_ok(), true);\n    |                          ^^^ method not found in `Formatter<'_, {integer}>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, {integer}>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, {integer}>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, {integer}>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 0 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, {integer}>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a\";",
                "    let err = &usize::MIN;",
                "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                "    let mut output = String::new();",
                "    let mut f = fmt::Formatter::new(&mut output);",
                "    formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(output.contains(\"error: \"), true);"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(output.lines().count(), 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(output.contains(\"regex parse error:\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(output.contains(\"error: \"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = &usize::MIN;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(output.lines().count(), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 1 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let err = &usize::MAX;",
                "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                "    let mut output = String::new();",
                "    let mut f = fmt::Formatter::new(&mut output);",
                "    formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(\"abc\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(\"error:\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(&usize::MAX.to_string()));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert_eq!(output.lines().count(), 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(\"abc\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(\"error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert!(output.contains(&usize::MAX.to_string()));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = &usize::MAX;",
                  "    let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = fmt::Formatter::new(&mut output);",
                  "    formatter.fmt(&mut f).unwrap();",
                  "    assert_eq!(output.lines().count(), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     formatter.fmt(&mut f).unwrap();\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     formatter.fmt(&mut f).unwrap();\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     formatter.fmt(&mut f).unwrap();\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     formatter.fmt(&mut f).unwrap();\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:36\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:74\n    |\n307 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:36\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:74\n    |\n314 |     let span = &ast::Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 3 } };\n    |                                                                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:310:17\n    |\n310 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     formatter.fmt(&mut f);\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:317:17\n    |\n317 |     let mut f = fmt::Formatter::new(&mut output);\n    |                 ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:15\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     formatter.fmt(&mut f).unwrap();\n    |               ^^^ method not found in `Formatter<'_, usize>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 14,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is false\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Err/None\n"
      ],
      "input_infer": "self.pattern: \"abc\"; line_number_width: 0; by_line: []; multi_line: []; err: \"Error message\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let span = ast::Span {",
                "        start: Position { line: 1, column: 1 },",
                "        end: Position { line: 1, column: 4 },",
                "    };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 0,",
                "        by_line: vec![vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    let error_message = \"Error message\";",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "    ",
                "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span {",
                  "    start: Position { line: 1, column: 1 },",
                  "    end: Position { line: 1, column: 4 },",
                  "    };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Error message\";",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(formatter.fmt(&mut std::fmt::Formatter::new()).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span {",
                  "        start: Position { line: 1, column: 1 },",
                  "        end: Position { line: 1, column: 4 },",
                  "    };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Error message\";",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span {",
                  "    start: Position { line: 1, column: 1 },",
                  "    end: Position { line: 1, column: 4 },",
                  "    };",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Error message\";",
                  "    let formatter = Formatter {",
                  "    pattern,",
                  "    err: &error_message,",
                  "    span: &span,",
                  "    aux_span: None,",
                  "    };",
                  "    assert!(formatter.fmt(&mut std::fmt::Formatter::new()).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:16\n    |\n307 |         start: Position { line: 1, column: 1 },\n    |                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n308 |         end: Position { line: 1, column: 4 },\n    |              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:327:12\n    |\n327 |     start: Position { line: 1, column: 1 },\n    |            ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:328:10\n    |\n328 |     end: Position { line: 1, column: 4 },\n    |          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:324:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:343:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n343 |     assert!(formatter.fmt(&mut std::fmt::Formatter::new()).is_err());\n    |                       ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:343:32\n    |\n343 |     assert!(formatter.fmt(&mut std::fmt::Formatter::new()).is_err());\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:343:32\n    |\n343 |     assert!(formatter.fmt(&mut std::fmt::Formatter::new()).is_err());\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n343 |     assert!(formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */)).is_err());\n    |                                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let span = ast::Span {",
                "        start: Position { line: 1, column: 1 },",
                "        end: Position { line: 1, column: 4 },",
                "    };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 0,",
                "        by_line: vec![vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    let error_message = \"Another error message\";",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "    ",
                "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.unwrap_err().to_string(), error_message);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span {",
                  "        start: Position { line: 1, column: 1 },",
                  "        end: Position { line: 1, column: 4 },",
                  "    };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span {",
                  "        start: Position { line: 1, column: 1 },",
                  "        end: Position { line: 1, column: 4 },",
                  "    };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span {",
                  "        start: Position { line: 1, column: 1 },",
                  "        end: Position { line: 1, column: 4 },",
                  "    };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"abc\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Another error message\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.unwrap_err().to_string(), error_message);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:16\n    |\n307 |         start: Position { line: 1, column: 1 },\n    |                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n308 |         end: Position { line: 1, column: 4 },\n    |              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:35\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:73\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:324:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:330:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:16\n    |\n307 |         start: Position { line: 1, column: 1 },\n    |                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n308 |         end: Position { line: 1, column: 4 },\n    |              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:35\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:73\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:324:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:330:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:16\n    |\n307 |         start: Position { line: 1, column: 1 },\n    |                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n308 |         end: Position { line: 1, column: 4 },\n    |              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:35\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:73\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 }};\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:324:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:330:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"\";",
                "    let span = ast::Span {",
                "        start: Position { line: 1, column: 1 },",
                "        end: Position { line: 1, column: 1 },",
                "    };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width: 0,",
                "        by_line: vec![vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    let error_message = \"Empty pattern error\";",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "    ",
                "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Empty pattern error\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \"\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Empty pattern error\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.unwrap_err().to_string(), \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let span = ast::Span {",
                  "        start: Position { line: 1, column: 1 },",
                  "        end: Position { line: 1, column: 1 },",
                  "    };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Empty pattern error\";",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Empty pattern error\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let span = ast::Span {",
                  "        start: Position { line: 1, column: 1 },",
                  "        end: Position { line: 1, column: 1 },",
                  "    };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    let error_message = \"Empty pattern error\";",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "    ",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    let pattern = \"\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let spans = Spans { pattern, line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let error_message = \"Empty pattern error\";",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let result = formatter.fmt(&mut std::fmt::Formatter::new());",
                  "    assert_eq!(result.unwrap_err().to_string(), \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:16\n    |\n307 |         start: Position { line: 1, column: 1 },\n    |                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n308 |         end: Position { line: 1, column: 1 },\n    |              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:35\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:73\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:324:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:330:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:16\n    |\n307 |         start: Position { line: 1, column: 1 },\n    |                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n308 |         end: Position { line: 1, column: 1 },\n    |              ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:35\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:326:73\n    |\n326 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:324:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:324:37\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n324 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:330:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0658]: use of unstable library feature 'fmt_internals': internal to standard library\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(fmt_internals)]` to the crate attributes to enable\n    = note: this compiler was built on 2024-07-20; consider upgrading it if it is out of date\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/error.rs:330:37\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new());\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut dyn std::fmt::Write` is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:286:12\nhelp: provide the argument\n    |\n330 |     let result = formatter.fmt(&mut std::fmt::Formatter::new(/* &mut dyn std::fmt::Write */));\n    |                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0432, E0599, E0658.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is false\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: write!(f, \"error: {}\", self.err)? is Err/None\n"
      ],
      "input_infer": "self.pattern = \"single line pattern\"; line_number_width = 0; by_line = [[]]; multi_line = []; resulting in Ok None, err = \"some error message\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"single line pattern\";",
                "    let line_number_width = 0;",
                "    let by_line = vec![vec![]];",
                "    let multi_line = vec![];",
                "    let error_message = \"some error message\";",
                "",
                "    let start_pos = Position { line: 1, column: 0 }; // assuming dummy Position struct",
                "    let end_pos = Position { line: 1, column: pattern.len() };",
                "",
                "    let span = Span { start: start_pos, end: end_pos };",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "    let formatter = Formatter {",
                "        pattern,",
                "        err: &error_message,",
                "        span: &span,",
                "        aux_span: None,",
                "    };",
                "",
                "    let mut output = String::new();",
                "    let result = formatter.fmt(&mut output);",
                "",
                "    // The result is an error to test the panic condition",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"single line pattern\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let error_message = \"some error message\";",
                  "    let start_pos = Position { line: 1, column: 0 };",
                  "    let end_pos = Position { line: 1, column: pattern.len() };",
                  "    let span = Span { start: start_pos, end: end_pos };",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"single line pattern\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let error_message = \"some error message\";",
                  "",
                  "    let start_pos = Position { line: 1, column: 0 }; // assuming dummy Position struct",
                  "    let end_pos = Position { line: 1, column: pattern.len() };",
                  "",
                  "    let span = Span { start: start_pos, end: end_pos };",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "    let formatter = Formatter {",
                  "        pattern,",
                  "        err: &error_message,",
                  "        span: &span,",
                  "        aux_span: None,",
                  "    };",
                  "",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "",
                  "    // The result is an error to test the panic condition",
                  "    assert!(result.is_err());",
                  "    let pattern = \"single line pattern\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let error_message = \"some error message\";",
                  "    let start_pos = Position { line: 1, column: 0 };",
                  "    let end_pos = Position { line: 1, column: pattern.len() };",
                  "    let span = Span { start: start_pos, end: end_pos };",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let formatter = Formatter { pattern, err: &error_message, span: &span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let result = formatter.fmt(&mut output);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:21\n    |\n311 |     let start_pos = Position { line: 1, column: 0 }; // assuming dummy Position struct\n    |                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:312:19\n    |\n312 |     let end_pos = Position { line: 1, column: pattern.len() };\n    |                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:314:16\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n314 |     let span = Span { start: start_pos, end: end_pos };\n    |                ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n314 |     let span = Spans { start: start_pos, end: end_pos };\n    |                ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:338:21\n    |\n338 |     let start_pos = Position { line: 1, column: 0 };\n    |                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:339:19\n    |\n339 |     let end_pos = Position { line: 1, column: pattern.len() };\n    |                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:340:16\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n340 |     let span = Span { start: start_pos, end: end_pos };\n    |                ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n340 |     let span = Spans { start: start_pos, end: end_pos };\n    |                ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:329:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n329 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:344:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n344 |     let result = formatter.fmt(&mut output);\n    |                            ^^^ method not found in `Formatter<'_, &str>`\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following traits which provide `fmt` are implemented but not in scope; perhaps you want to import one of them\n    |\n300 +    use std::fmt::Binary;\n    |\n300 +    use std::fmt::Debug;\n    |\n300 +    use std::fmt::Display;\n    |\n300 +    use std::fmt::LowerExp;\n    |\n      and 5 other candidates\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 16,
      "prompt_conds": [
        "// constraint: self.pattern.contains('\\n') is false\n",
        "// constraint: writeln!(f, \"regex parse error:\")? is Ok/Some\n",
        "// constraint: write!(f, \"{}\", notated)? is Ok/Some\n",
        "// constraint: write!(f, \"error: {}\", self.err)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "self.pattern: empty string to a single line of valid regex (e.g., \"\", \"a\", \"abc\"); f: valid writable formatter; self.err: valid displayable error type\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"\";",
                "    let err = \"Syntax error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                "    let mut output = String::new();",
                "    let mut f = &mut output;",
                "    let _ = formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    assert!(formatter.fmt(&mut f).is_ok());"
                ],
                [
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    assert!(output.contains(\"error: Syntax error\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    assert!(formatter.fmt(&mut f).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"\";",
                  "    let err = \"Syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    assert!(output.contains(\"error: Syntax error\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     assert!(formatter.fmt(&mut f).is_ok());\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     assert!(Box::new(formatter).fmt(&mut f).is_ok());\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     assert!(Arc::new(formatter).fmt(&mut f).is_ok());\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     assert!(Rc::new(formatter).fmt(&mut f).is_ok());\n    |             ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 1 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a\";",
                "    let err = \"Single character syntax error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                "    let mut output = String::new();",
                "    let mut f = &mut output;",
                "    let _ = formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"error: Single character syntax error\"));"
                ],
                [
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"a\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"error: Single character syntax error\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a\";",
                  "    let err = \"Single character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"a\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 2 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let err = \"Multiple character syntax error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                "    let mut output = String::new();",
                "    let mut f = &mut output;",
                "    let _ = formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"error: Multiple character syntax error\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"abc\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"error: Multiple character syntax error\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"abc\";",
                  "    let err = \"Multiple character syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: None };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"abc\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:35\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:314:73\n    |\n314 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:308:47\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n308 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:308:42\n    |\n308 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:311:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n311 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n311 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:315:47\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n315 |     let formatter = Formatter { pattern, err, span: &span, aux_span: None };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:315:42\n    |\n315 |     let formatter = Formatter { pattern, err, span, aux_span: None };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:318:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n318 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n318 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"a+b\";",
                "    let err = \"Quantifier syntax error\";",
                "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                "    let mut output = String::new();",
                "    let mut f = &mut output;",
                "    let _ = formatter.fmt(&mut f);",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"regex parse error:\"));"
                ],
                [
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"error: Quantifier syntax error\"));"
                ],
                [
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"a+b\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"regex parse error:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"error: Quantifier syntax error\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let _ = formatter.fmt(&mut f);",
                  "    let pattern = \"a+b\";",
                  "    let err = \"Quantifier syntax error\";",
                  "    let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };",
                  "    let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };",
                  "    let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };",
                  "    let mut output = String::new();",
                  "    let mut f = &mut output;",
                  "    let result = formatter.fmt(&mut f);",
                  "    assert!(output.contains(\"a+b\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:39\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:77\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:47\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:309:42\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:317:47\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n317 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:317:42\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:39\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:77\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:47\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:309:42\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:317:47\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n317 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:317:42\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:39\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:77\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:47\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:309:42\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:317:47\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n317 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:317:42\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:35\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:307:73\n    |\n307 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:39\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:308:77\n    |\n308 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:35\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:315:73\n    |\n315 |     let span = ast::Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 4 } };\n    |                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:39\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                       ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:316:77\n    |\n316 |     let aux_span = ast::Span { start: Position { line: 1, column: 2 }, end: Position { line: 1, column: 3 } };\n    |                                                                             ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:309:47\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n309 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:309:42\n    |\n309 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:312:23\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n312 |     let _ = formatter.fmt(&mut f);\n    |                       ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Box::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Arc::new(formatter).fmt(&mut f);\n    |             +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n312 |     let _ = Rc::new(formatter).fmt(&mut f);\n    |             ++++++++         +\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:317:47\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                               ^^^^ expected `&Span`, found `Span`\n    |\nhelp: consider borrowing here\n    |\n317 |     let formatter = Formatter { pattern, err, span: &span, aux_span: Some(&aux_span) };\n    |                                               +++++++\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> regex-syntax/src/error.rs:317:42\n    |\n317 |     let formatter = Formatter { pattern, err, span, aux_span: Some(&aux_span) };\n    |                                          ^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required by an implicit `Sized` bound in `error::Formatter`\n   --> regex-syntax/src/error.rs:68:26\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    |                          ^ required by the implicit `Sized` requirement on this type parameter in `Formatter`\nhelp: consider relaxing the implicit `Sized` restriction\n    |\n68  | pub struct Formatter<'e, E: 'e + ?Sized> {\n    |                                ++++++++\n\nerror[E0599]: no method named `fmt` found for struct `error::Formatter` in the current scope\n   --> regex-syntax/src/error.rs:320:28\n    |\n68  | pub struct Formatter<'e, E: 'e> {\n    | ------------------------------- method `fmt` not found for this struct\n...\n320 |     let result = formatter.fmt(&mut f);\n    |                            ^^^ method not found in `Formatter<'_, str>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:1027:8\n    |\n    = note: the method is available for `Box<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Arc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `Rc<error::Formatter<'_, str>>` here\n    |\n    = note: the method is available for `&mut error::Formatter<'_, str>` here\n    |\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Box::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Arc::new(formatter).fmt(&mut f);\n    |                  +++++++++         +\nhelp: consider wrapping the receiver expression with the appropriate type\n    |\n320 |     let result = Rc::new(formatter).fmt(&mut f);\n    |                  ++++++++         +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}