{
  "name": "regex::input::<&'a T as input::Input>::next_char",
  "name_with_impl": "regex::input::{impl#1}::next_char",
  "mod_info": {
    "name": "input",
    "loc": "src/lib.rs:655:1:655:11"
  },
  "visible": true,
  "loc": "src/input.rs:117:5:117:72",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "0 <= pos <= 2^32 - 1, 0 <= len <= 1000, byte = 0 or 1, (0..=len) for InputAt.pos, valid Char(u32) values for next_char.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestInput {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl Input for TestInput {",
                "        fn at(&self, i: usize) -> InputAt {",
                "            InputAt {",
                "                pos: i,",
                "                c: Char(97), // ASCII for 'a'",
                "                byte: Some(self.data[i]),",
                "                len: self.data.len(),",
                "            }",
                "        }",
                "        ",
                "        fn next_char(&self, at: InputAt) -> Char {",
                "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                "        }",
                "        ",
                "        fn previous_char(&self, at: InputAt) -> Char {",
                "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                "        }",
                "        ",
                "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                "            false",
                "        }",
                "",
                "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                "            None",
                "        }",
                "",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn as_bytes(&self) -> &[u8] {",
                "            &self.data",
                "        }",
                "    }",
                "",
                "    let input = TestInput { data: vec![0, 1, 2] };",
                "    let at = input.at(0);",
                "    let _next = input.next_char(at);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(98)); // next_char of 'a' should be 'b'"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(99)); // next_char of 'b' should be 'c'"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(0)); // next_char of 'c' should wrap around to '0' (ASCII)"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    assert_eq!(previous_char_result, Char(127)); // previous_char of 'a' should be '' (ASCII)"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    let at = input.at(1);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    assert_eq!(previous_char_result, Char(98)); // previous_char of 'b' should be 'a'"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    let at = input.at(1);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    let at = input.at(2);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    assert_eq!(previous_char_result, Char(99)); // previous_char of 'c' should be 'b'"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(97), // ASCII for 'a'",
                  "                byte: Some(self.data[i]),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(98)); // next_char of 'a' should be 'b'",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(97), // ASCII for 'a'",
                  "                byte: Some(self.data[i]),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(99)); // next_char of 'b' should be 'c'",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(97), // ASCII for 'a'",
                  "                byte: Some(self.data[i]),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(0)); // next_char of 'c' should wrap around to '0' (ASCII)",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(97), // ASCII for 'a'",
                  "                byte: Some(self.data[i]),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    assert_eq!(previous_char_result, Char(127)); // previous_char of 'a' should be '' (ASCII)",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(97), // ASCII for 'a'",
                  "                byte: Some(self.data[i]),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    let at = input.at(1);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    assert_eq!(previous_char_result, Char(98)); // previous_char of 'b' should be 'a'",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(97), // ASCII for 'a'",
                  "                byte: Some(self.data[i]),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128) // Simple increment for testing",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128) // Simple decrement for testing",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    let at = input.at(1);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    let at = input.at(2);",
                  "    let previous_char_result = input.previous_char(at);",
                  "    assert_eq!(previous_char_result, Char(99)); // previous_char of 'c' should be 'b'",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestInput {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl Input for TestInput {",
                "        fn at(&self, i: usize) -> InputAt {",
                "            InputAt {",
                "                pos: i,",
                "                c: Char(0),",
                "                byte: Some(0),",
                "                len: self.data.len(),",
                "            }",
                "        }",
                "        ",
                "        fn next_char(&self, at: InputAt) -> Char {",
                "            Char((at.c.0 + 1) % 128)",
                "        }",
                "        ",
                "        fn previous_char(&self, at: InputAt) -> Char {",
                "            Char((at.c.0 + 127) % 128)",
                "        }",
                "        ",
                "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                "            false",
                "        }",
                "",
                "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                "            None",
                "        }",
                "",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn as_bytes(&self) -> &[u8] {",
                "            &self.data",
                "        }",
                "    }",
                "",
                "    let input = TestInput { data: vec![0] };",
                "    let at = input.at(0);",
                "    let _next = input.next_char(at);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result.0, 1);"
                ],
                [
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result.0 % 128, 1);"
                ],
                [
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    assert_eq!(next_char_result_from_next.0, 0);"
                ],
                [
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    let at_empty = input.at(0);",
                  "    assert!(input.is_empty_match(at_empty, &InstEmptyLook));"
                ],
                [
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    let at_empty = input.at(0);",
                  "    assert_eq!(input.len(), 1);"
                ],
                [
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    let at_empty = input.at(0);",
                  "    assert!(input.as_bytes() == &[0]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(0),",
                  "                byte: Some(0),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result.0, 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(0),",
                  "                byte: Some(0),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result.0 % 128, 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(0),",
                  "                byte: Some(0),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    assert_eq!(next_char_result_from_next.0, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(0),",
                  "                byte: Some(0),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    let at_empty = input.at(0);",
                  "    assert!(input.is_empty_match(at_empty, &InstEmptyLook));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(0),",
                  "                byte: Some(0),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    let at_empty = input.at(0);",
                  "    assert_eq!(input.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(0),",
                  "                byte: Some(0),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0] };",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at_next = input.at(1);",
                  "    let next_char_result_from_next = input.next_char(at_next);",
                  "    let at_empty = input.at(0);",
                  "    assert!(input.as_bytes() == &[0]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0423]: expected value, found struct `InstEmptyLook`\n   --> src/input.rs:476:45\n    |\n476 |       assert!(input.is_empty_match(at_empty, &InstEmptyLook));\n    |                                               ^^^^^^^^^^^^^ help: use struct literal syntax instead: `InstEmptyLook { goto: val, look: val }`\n    |\n   ::: src/prog.rs:321:1\n    |\n321 | / pub struct InstEmptyLook {\n322 | |     /// The next location to execute in the program if this instruction\n323 | |     /// succeeds.\n324 | |     pub goto: InstPtr,\n325 | |     /// The type of zero-width assertion to check.\n326 | |     pub look: EmptyLook,\n327 | | }\n    | |_- `InstEmptyLook` defined here\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nFor more information about this error, try `rustc --explain E0423`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 1 previous error; 31 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestInput {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl Input for TestInput {",
                "        fn at(&self, i: usize) -> InputAt {",
                "            InputAt {",
                "                pos: i,",
                "                c: Char(u32::MAX),",
                "                byte: Some(1),",
                "                len: self.data.len(),",
                "            }",
                "        }",
                "        ",
                "        fn next_char(&self, at: InputAt) -> Char {",
                "            Char((at.c.0 + 1) % 128)",
                "        }",
                "        ",
                "        fn previous_char(&self, at: InputAt) -> Char {",
                "            Char((at.c.0 + 127) % 128)",
                "        }",
                "        ",
                "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                "            false",
                "        }",
                "",
                "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                "            None",
                "        }",
                "",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn as_bytes(&self) -> &[u8] {",
                "            &self.data",
                "        }",
                "    }",
                "",
                "    let input = TestInput { data: vec![0, 1, 2] };",
                "    let at = input.at(2); ",
                "    let _next = input.next_char(at);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(0));"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(2));"
                ],
                [
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(1));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(u32::MAX),",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2); ",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(0));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(u32::MAX),",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2); ",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(2));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(u32::MAX),",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 1) % 128)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char((at.c.0 + 127) % 128)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2); ",
                  "    let _next = input.next_char(at);",
                  "    let input = TestInput { data: vec![0, 1, 2] };",
                  "    let at = input.at(2);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(1);",
                  "    let next_char_result = input.next_char(at);",
                  "    let at = input.at(0);",
                  "    let next_char_result = input.next_char(at);",
                  "    assert_eq!(next_char_result, Char(1));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestInput {",
                "        data: Vec<u8>,",
                "    }",
                "",
                "    impl Input for TestInput {",
                "        fn at(&self, i: usize) -> InputAt {",
                "            InputAt {",
                "                pos: i,",
                "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                "                byte: Some(1),",
                "                len: self.data.len(),",
                "            }",
                "        }",
                "        ",
                "        fn next_char(&self, at: InputAt) -> Char {",
                "            Char(at.c.0 + 1)",
                "        }",
                "        ",
                "        fn previous_char(&self, at: InputAt) -> Char {",
                "            Char(at.c.0 - 1)",
                "        }",
                "        ",
                "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                "            false",
                "        }",
                "",
                "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                "            None",
                "        }",
                "",
                "        fn len(&self) -> usize {",
                "            self.data.len()",
                "        }",
                "",
                "        fn as_bytes(&self) -> &[u8] {",
                "            &self.data",
                "        }",
                "    }",
                "",
                "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                "    for i in 0..1000 {",
                "        let at = input.at(i);",
                "        let _next = input.next_char(at);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    assert_eq!(input.next_char(at), Char(101));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    assert_eq!(input.next_char(at), Char(102));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    assert_eq!(input.next_char(at), Char(103));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    assert_eq!(input.next_char(at), Char(104));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    assert_eq!(input.next_char(at), Char(105));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    assert_eq!(input.next_char(at), Char(106));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    assert_eq!(input.next_char(at), Char(107));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    assert_eq!(input.next_char(at), Char(108));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    assert_eq!(input.next_char(at), Char(109));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    assert_eq!(input.next_char(at), Char(110));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    assert_eq!(input.next_char(at), Char(111));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    assert_eq!(input.next_char(at), Char(112));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    assert_eq!(input.next_char(at), Char(113));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    assert_eq!(input.next_char(at), Char(114));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    assert_eq!(input.next_char(at), Char(115));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    assert_eq!(input.next_char(at), Char(116));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    assert_eq!(input.next_char(at), Char(117));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    assert_eq!(input.next_char(at), Char(118));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    assert_eq!(input.next_char(at), Char(119));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    assert_eq!(input.next_char(at), Char(120));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    assert_eq!(input.next_char(at), Char(121));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    assert_eq!(input.next_char(at), Char(122));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    assert_eq!(input.next_char(at), Char(123));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    assert_eq!(input.next_char(at), Char(124));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    assert_eq!(input.next_char(at), Char(125));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    assert_eq!(input.next_char(at), Char(126));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    assert_eq!(input.next_char(at), Char(127));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    assert_eq!(input.next_char(at), Char(128));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    assert_eq!(input.next_char(at), Char(129));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    assert_eq!(input.next_char(at), Char(130));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    assert_eq!(input.next_char(at), Char(131));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    assert_eq!(input.next_char(at), Char(132));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    assert_eq!(input.next_char(at), Char(133));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    assert_eq!(input.next_char(at), Char(134));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    assert_eq!(input.next_char(at), Char(135));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    assert_eq!(input.next_char(at), Char(136));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    assert_eq!(input.next_char(at), Char(137));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    assert_eq!(input.next_char(at), Char(138));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    assert_eq!(input.next_char(at), Char(139));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    assert_eq!(input.next_char(at), Char(140));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    assert_eq!(input.next_char(at), Char(141));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    assert_eq!(input.next_char(at), Char(142));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    assert_eq!(input.next_char(at), Char(143));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    assert_eq!(input.next_char(at), Char(144));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    assert_eq!(input.next_char(at), Char(145));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    assert_eq!(input.next_char(at), Char(146));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    assert_eq!(input.next_char(at), Char(147));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    assert_eq!(input.next_char(at), Char(148));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    assert_eq!(input.next_char(at), Char(149));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    assert_eq!(input.next_char(at), Char(150));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    assert_eq!(input.next_char(at), Char(151));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    assert_eq!(input.next_char(at), Char(152));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    assert_eq!(input.next_char(at), Char(153));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    assert_eq!(input.next_char(at), Char(154));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    assert_eq!(input.next_char(at), Char(155));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    assert_eq!(input.next_char(at), Char(156));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    assert_eq!(input.next_char(at), Char(157));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    assert_eq!(input.next_char(at), Char(158));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    assert_eq!(input.next_char(at), Char(159));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    assert_eq!(input.next_char(at), Char(160));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    assert_eq!(input.next_char(at), Char(161));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    assert_eq!(input.next_char(at), Char(162));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    assert_eq!(input.next_char(at), Char(163));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    assert_eq!(input.next_char(at), Char(164));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    assert_eq!(input.next_char(at), Char(165));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    assert_eq!(input.next_char(at), Char(166));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    assert_eq!(input.next_char(at), Char(167));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    assert_eq!(input.next_char(at), Char(168));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    assert_eq!(input.next_char(at), Char(169));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    assert_eq!(input.next_char(at), Char(170));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    assert_eq!(input.next_char(at), Char(171));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    assert_eq!(input.next_char(at), Char(172));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    assert_eq!(input.next_char(at), Char(173));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    assert_eq!(input.next_char(at), Char(174));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    assert_eq!(input.next_char(at), Char(175));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    assert_eq!(input.next_char(at), Char(176));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    assert_eq!(input.next_char(at), Char(177));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    assert_eq!(input.next_char(at), Char(178));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    assert_eq!(input.next_char(at), Char(179));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    assert_eq!(input.next_char(at), Char(180));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    assert_eq!(input.next_char(at), Char(181));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    assert_eq!(input.next_char(at), Char(182));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    assert_eq!(input.next_char(at), Char(183));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    assert_eq!(input.next_char(at), Char(184));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    assert_eq!(input.next_char(at), Char(185));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    assert_eq!(input.next_char(at), Char(186));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    assert_eq!(input.next_char(at), Char(187));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    assert_eq!(input.next_char(at), Char(188));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    assert_eq!(input.next_char(at), Char(189));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    assert_eq!(input.next_char(at), Char(190));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    assert_eq!(input.next_char(at), Char(191));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    assert_eq!(input.next_char(at), Char(192));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    assert_eq!(input.next_char(at), Char(193));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    assert_eq!(input.next_char(at), Char(194));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    assert_eq!(input.next_char(at), Char(195));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    assert_eq!(input.next_char(at), Char(196));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    assert_eq!(input.next_char(at), Char(197));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    let at = input.at(97);",
                  "    assert_eq!(input.next_char(at), Char(198));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    let at = input.at(97);",
                  "    let at = input.at(98);",
                  "    assert_eq!(input.next_char(at), Char(199));"
                ],
                [
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    let at = input.at(97);",
                  "    let at = input.at(98);",
                  "    let at = input.at(99);",
                  "    assert_eq!(input.next_char(at), Char(200));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    assert_eq!(input.next_char(at), Char(101));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    assert_eq!(input.next_char(at), Char(102));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    assert_eq!(input.next_char(at), Char(103));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    assert_eq!(input.next_char(at), Char(104));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    assert_eq!(input.next_char(at), Char(105));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    assert_eq!(input.next_char(at), Char(106));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    assert_eq!(input.next_char(at), Char(107));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    assert_eq!(input.next_char(at), Char(108));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    assert_eq!(input.next_char(at), Char(109));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    assert_eq!(input.next_char(at), Char(110));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    assert_eq!(input.next_char(at), Char(111));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    assert_eq!(input.next_char(at), Char(112));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    assert_eq!(input.next_char(at), Char(113));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    assert_eq!(input.next_char(at), Char(114));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    assert_eq!(input.next_char(at), Char(115));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    assert_eq!(input.next_char(at), Char(116));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    assert_eq!(input.next_char(at), Char(117));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    assert_eq!(input.next_char(at), Char(118));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    assert_eq!(input.next_char(at), Char(119));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    assert_eq!(input.next_char(at), Char(120));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    assert_eq!(input.next_char(at), Char(121));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    assert_eq!(input.next_char(at), Char(122));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    assert_eq!(input.next_char(at), Char(123));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    assert_eq!(input.next_char(at), Char(124));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    assert_eq!(input.next_char(at), Char(125));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    assert_eq!(input.next_char(at), Char(126));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    assert_eq!(input.next_char(at), Char(127));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    assert_eq!(input.next_char(at), Char(128));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    assert_eq!(input.next_char(at), Char(129));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    assert_eq!(input.next_char(at), Char(130));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    assert_eq!(input.next_char(at), Char(131));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    assert_eq!(input.next_char(at), Char(132));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    assert_eq!(input.next_char(at), Char(133));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    assert_eq!(input.next_char(at), Char(134));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    assert_eq!(input.next_char(at), Char(135));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    assert_eq!(input.next_char(at), Char(136));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    assert_eq!(input.next_char(at), Char(137));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    assert_eq!(input.next_char(at), Char(138));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    assert_eq!(input.next_char(at), Char(139));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    assert_eq!(input.next_char(at), Char(140));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    assert_eq!(input.next_char(at), Char(141));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    assert_eq!(input.next_char(at), Char(142));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    assert_eq!(input.next_char(at), Char(143));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    assert_eq!(input.next_char(at), Char(144));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    assert_eq!(input.next_char(at), Char(145));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    assert_eq!(input.next_char(at), Char(146));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    assert_eq!(input.next_char(at), Char(147));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    assert_eq!(input.next_char(at), Char(148));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    assert_eq!(input.next_char(at), Char(149));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    assert_eq!(input.next_char(at), Char(150));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    assert_eq!(input.next_char(at), Char(151));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    assert_eq!(input.next_char(at), Char(152));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    assert_eq!(input.next_char(at), Char(153));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    assert_eq!(input.next_char(at), Char(154));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    assert_eq!(input.next_char(at), Char(155));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    assert_eq!(input.next_char(at), Char(156));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    assert_eq!(input.next_char(at), Char(157));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    assert_eq!(input.next_char(at), Char(158));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    assert_eq!(input.next_char(at), Char(159));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    assert_eq!(input.next_char(at), Char(160));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    assert_eq!(input.next_char(at), Char(161));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    assert_eq!(input.next_char(at), Char(162));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    assert_eq!(input.next_char(at), Char(163));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    assert_eq!(input.next_char(at), Char(164));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    assert_eq!(input.next_char(at), Char(165));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    assert_eq!(input.next_char(at), Char(166));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    assert_eq!(input.next_char(at), Char(167));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    assert_eq!(input.next_char(at), Char(168));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    assert_eq!(input.next_char(at), Char(169));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    assert_eq!(input.next_char(at), Char(170));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    assert_eq!(input.next_char(at), Char(171));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    assert_eq!(input.next_char(at), Char(172));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    assert_eq!(input.next_char(at), Char(173));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    assert_eq!(input.next_char(at), Char(174));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    assert_eq!(input.next_char(at), Char(175));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    assert_eq!(input.next_char(at), Char(176));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    assert_eq!(input.next_char(at), Char(177));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    assert_eq!(input.next_char(at), Char(178));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    assert_eq!(input.next_char(at), Char(179));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    assert_eq!(input.next_char(at), Char(180));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    assert_eq!(input.next_char(at), Char(181));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    assert_eq!(input.next_char(at), Char(182));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    assert_eq!(input.next_char(at), Char(183));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    assert_eq!(input.next_char(at), Char(184));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    assert_eq!(input.next_char(at), Char(185));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    assert_eq!(input.next_char(at), Char(186));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    assert_eq!(input.next_char(at), Char(187));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    assert_eq!(input.next_char(at), Char(188));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    assert_eq!(input.next_char(at), Char(189));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    assert_eq!(input.next_char(at), Char(190));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    assert_eq!(input.next_char(at), Char(191));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    assert_eq!(input.next_char(at), Char(192));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    assert_eq!(input.next_char(at), Char(193));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    assert_eq!(input.next_char(at), Char(194));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    assert_eq!(input.next_char(at), Char(195));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    assert_eq!(input.next_char(at), Char(196));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    assert_eq!(input.next_char(at), Char(197));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    let at = input.at(97);",
                  "    assert_eq!(input.next_char(at), Char(198));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    let at = input.at(97);",
                  "    let at = input.at(98);",
                  "    assert_eq!(input.next_char(at), Char(199));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestInput {",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input for TestInput {",
                  "        fn at(&self, i: usize) -> InputAt {",
                  "            InputAt {",
                  "                pos: i,",
                  "                c: Char(100 + i as u32), // generates a sequence of ASCII characters",
                  "                byte: Some(1),",
                  "                len: self.data.len(),",
                  "            }",
                  "        }",
                  "        ",
                  "        fn next_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 + 1)",
                  "        }",
                  "        ",
                  "        fn previous_char(&self, at: InputAt) -> Char {",
                  "            Char(at.c.0 - 1)",
                  "        }",
                  "        ",
                  "        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {",
                  "            false",
                  "        }",
                  "",
                  "        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {",
                  "            None",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn as_bytes(&self) -> &[u8] {",
                  "            &self.data",
                  "        }",
                  "    }",
                  "",
                  "    let input = TestInput { data: vec![0; 1000] }; // maximum length",
                  "    for i in 0..1000 {",
                  "        let at = input.at(i);",
                  "        let _next = input.next_char(at);",
                  "    }",
                  "    let input = TestInput { data: vec![0; 1000] };",
                  "    let at = input.at(0);",
                  "    let at = input.at(1);",
                  "    let at = input.at(2);",
                  "    let at = input.at(3);",
                  "    let at = input.at(4);",
                  "    let at = input.at(5);",
                  "    let at = input.at(6);",
                  "    let at = input.at(7);",
                  "    let at = input.at(8);",
                  "    let at = input.at(9);",
                  "    let at = input.at(10);",
                  "    let at = input.at(11);",
                  "    let at = input.at(12);",
                  "    let at = input.at(13);",
                  "    let at = input.at(14);",
                  "    let at = input.at(15);",
                  "    let at = input.at(16);",
                  "    let at = input.at(17);",
                  "    let at = input.at(18);",
                  "    let at = input.at(19);",
                  "    let at = input.at(20);",
                  "    let at = input.at(21);",
                  "    let at = input.at(22);",
                  "    let at = input.at(23);",
                  "    let at = input.at(24);",
                  "    let at = input.at(25);",
                  "    let at = input.at(26);",
                  "    let at = input.at(27);",
                  "    let at = input.at(28);",
                  "    let at = input.at(29);",
                  "    let at = input.at(30);",
                  "    let at = input.at(31);",
                  "    let at = input.at(32);",
                  "    let at = input.at(33);",
                  "    let at = input.at(34);",
                  "    let at = input.at(35);",
                  "    let at = input.at(36);",
                  "    let at = input.at(37);",
                  "    let at = input.at(38);",
                  "    let at = input.at(39);",
                  "    let at = input.at(40);",
                  "    let at = input.at(41);",
                  "    let at = input.at(42);",
                  "    let at = input.at(43);",
                  "    let at = input.at(44);",
                  "    let at = input.at(45);",
                  "    let at = input.at(46);",
                  "    let at = input.at(47);",
                  "    let at = input.at(48);",
                  "    let at = input.at(49);",
                  "    let at = input.at(50);",
                  "    let at = input.at(51);",
                  "    let at = input.at(52);",
                  "    let at = input.at(53);",
                  "    let at = input.at(54);",
                  "    let at = input.at(55);",
                  "    let at = input.at(56);",
                  "    let at = input.at(57);",
                  "    let at = input.at(58);",
                  "    let at = input.at(59);",
                  "    let at = input.at(60);",
                  "    let at = input.at(61);",
                  "    let at = input.at(62);",
                  "    let at = input.at(63);",
                  "    let at = input.at(64);",
                  "    let at = input.at(65);",
                  "    let at = input.at(66);",
                  "    let at = input.at(67);",
                  "    let at = input.at(68);",
                  "    let at = input.at(69);",
                  "    let at = input.at(70);",
                  "    let at = input.at(71);",
                  "    let at = input.at(72);",
                  "    let at = input.at(73);",
                  "    let at = input.at(74);",
                  "    let at = input.at(75);",
                  "    let at = input.at(76);",
                  "    let at = input.at(77);",
                  "    let at = input.at(78);",
                  "    let at = input.at(79);",
                  "    let at = input.at(80);",
                  "    let at = input.at(81);",
                  "    let at = input.at(82);",
                  "    let at = input.at(83);",
                  "    let at = input.at(84);",
                  "    let at = input.at(85);",
                  "    let at = input.at(86);",
                  "    let at = input.at(87);",
                  "    let at = input.at(88);",
                  "    let at = input.at(89);",
                  "    let at = input.at(90);",
                  "    let at = input.at(91);",
                  "    let at = input.at(92);",
                  "    let at = input.at(93);",
                  "    let at = input.at(94);",
                  "    let at = input.at(95);",
                  "    let at = input.at(96);",
                  "    let at = input.at(97);",
                  "    let at = input.at(98);",
                  "    let at = input.at(99);",
                  "    assert_eq!(input.next_char(at), Char(200));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}