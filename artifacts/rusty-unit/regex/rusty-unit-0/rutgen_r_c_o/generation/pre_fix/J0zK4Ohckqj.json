{
  "name": "regex_syntax::error::error::Spans<'p>::notate",
  "name_with_impl": "regex_syntax::error::{impl#7}::notate",
  "mod_info": {
    "name": "error",
    "loc": "regex-syntax/src/lib.rs:115:1:115:11"
  },
  "visible": false,
  "loc": "regex-syntax/src/error.rs:211:5:228:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: (i, line) in self.pattern.lines().enumerate() is true\n",
        "// constraint: self.line_number_width > 0 is true\n",
        "// constraint: let Some(notes) = self.notate_line(i) is true\n",
        "// constraint: (i, line) in self.pattern.lines().enumerate() is false\n",
        "// expected return value/type: notated\n"
      ],
      "input_infer": "line_number_width: 1-10, pattern: non-empty string with multiple lines (2-10 lines with 1-50 characters per line), spans: 1-5 span per line\n",
      "answers": [
        {
          "uses": [
            "use super::Position;"
          ],
          "has_test_mod": false,
          "common": [
            "struct Position {",
            "    column: usize,",
            "}",
            "",
            "mod ast {",
            "",
            "    #[derive(Clone)]",
            "    pub struct Span {",
            "        pub start: Position,",
            "        pub end: Position,",
            "    }",
            "}",
            "",
            "struct Formatter<'e, E: std::fmt::Display> {",
            "    // Placeholder for example",
            "    _marker: std::marker::PhantomData<&'e E>,",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"First line\\nSecond line\";",
                "    let line_number_width = 2;",
                "    let spans = vec![",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                "    ];",
                "",
                "    let mut spans_instance = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line: spans,",
                "        multi_line: vec![],",
                "    };",
                "",
                "    let _ = spans_instance.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.notate(), \" 1: First line\\n ^^^^\\n 2: Second line\\n ^^^^^^\\n\");"
                ],
                [
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.line_number_width, 2);"
                ],
                [
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line.len(), 2);"
                ],
                [
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(spans_instance.multi_line.is_empty());"
                ],
                [
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.pattern.lines().count(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.notate(), \" 1: First line\\n ^^^^\\n 2: Second line\\n ^^^^^^\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.line_number_width, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert!(spans_instance.multi_line.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"First line\\nSecond line\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.pattern.lines().count(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:333:18\n    |\n333 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:347:14\n    |\n347 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:333:18\n    |\n333 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:347:14\n    |\n347 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:333:18\n    |\n333 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:347:14\n    |\n347 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:333:18\n    |\n333 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:347:14\n    |\n347 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:333:18\n    |\n333 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:347:14\n    |\n347 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"Line one\\nLine two\\nLine three\";",
                "    let line_number_width = 3;",
                "    let spans = vec![",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                "    ];",
                "    ",
                "    let mut spans_instance = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line: spans,",
                "        multi_line: vec![],",
                "    };",
                "",
                "    let _ = spans_instance.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert_eq!(notated, \"  1: Line one\\n    ^^^\\n  2: Line two\\n    ^^^^^\\n  3: Line three\\n    ^^^^^^\\n\");"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"  1:\"));"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"  2:\"));"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"  3:\"));"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"^\"));"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.ends_with('\\n'));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    ",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert_eq!(notated, \"  1: Line one\\n    ^^^\\n  2: Line two\\n    ^^^^^\\n  3: Line three\\n    ^^^^^^\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    ",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"  1:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    ",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"  2:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    ",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"  3:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    ",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.contains(\"^\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    ",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    let notated = spans_instance.notate();",
                  "    assert!(notated.ends_with('\\n'));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"Single line only\";",
                "    let line_number_width = 0;",
                "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                "",
                "    let mut spans_instance = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line: spans,",
                "        multi_line: vec![],",
                "    };",
                "",
                "    let _ = spans_instance.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \"    Single line only\\n      ^^^^^\\n\\n\");"
                ],
                [
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \" 1: Multiple\\n 2: lines of text\\n     ^^^^\\n\\n\");"
                ],
                [
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Another test\\nwith errors\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \" 1: Another test\\n     ^^^^^\\n 2: with errors\\n\\n\");"
                ],
                [
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Another test\\nwith errors\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Empty pattern\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \" 1: Empty pattern\\n\\n\");"
                ],
                [
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Another test\\nwith errors\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Empty pattern\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Only\\ntwo lines\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 3 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \"    Only\\n    ^^\\n    two lines\\n\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \"    Single line only\\n      ^^^^^\\n\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \" 1: Multiple\\n 2: lines of text\\n     ^^^^\\n\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Another test\\nwith errors\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \" 1: Another test\\n     ^^^^^\\n 2: with errors\\n\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Another test\\nwith errors\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Empty pattern\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \" 1: Empty pattern\\n\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Single line only\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Multiple\\nlines of text\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 5 } }]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Another test\\nwith errors\";",
                  "    let line_number_width = 3;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Empty pattern\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    let pattern = \"Only\\ntwo lines\";",
                  "    let line_number_width = 0;",
                  "    let spans = vec![vec![ast::Span { start: Position { column: 1 }, end: Position { column: 3 } }], vec![]];",
                  "    let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };",
                  "    let notated_result = spans_instance.notate();",
                  "    assert_eq!(notated_result, \"    Only\\n    ^^\\n    two lines\\n\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:330:18\n    |\n330 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:338:75\n    |\n338 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:330:18\n    |\n330 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:338:75\n    |\n338 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:343:75\n    |\n343 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:330:18\n    |\n330 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:338:75\n    |\n338 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:343:75\n    |\n343 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:348:75\n    |\n348 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:330:18\n    |\n330 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:338:75\n    |\n338 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:343:75\n    |\n343 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:348:75\n    |\n348 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:330:18\n    |\n330 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:338:75\n    |\n338 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:343:75\n    |\n343 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:348:75\n    |\n348 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:358:75\n    |\n358 |     let mut spans_instance = Spans { pattern, line_number_width, by_line: spans, multi_line: vec![] };\n    |                                                                           ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"Line one\\n\\nLine three\";",
                "    let line_number_width = 2;",
                "    let spans = vec![",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                "        vec![], // Empty spans for the empty line",
                "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                "    ];",
                "",
                "    let mut spans_instance = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line: spans,",
                "        multi_line: vec![],",
                "    };",
                "",
                "    let _ = spans_instance.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.line_number_width, 2);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.pattern, \"Line one\\n\\nLine three\");"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line.len(), 3);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[0].len(), 1);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[1].len(), 0);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[2].len(), 1);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[2][0].start.column, 1);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[2][0].end.column, 6);"
                ],
                [
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.notate(), \" 1: Line one\\n    ^\\n 2: \\n 3: Line three\\n    ^^^^^^\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.line_number_width, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.pattern, \"Line one\\n\\nLine three\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[0].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[1].len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[2].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[2][0].start.column, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.by_line[2][0].end.column, 6);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "        vec![], // Empty spans for the empty line",
                  "        vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\n\\nLine three\";",
                  "    let line_number_width = 2;",
                  "    let spans = vec![",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
                  "    vec![],",
                  "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 6 } }],",
                  "    ];",
                  "    let spans_instance = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line: spans,",
                  "    multi_line: vec![],",
                  "    };",
                  "    assert_eq!(spans_instance.notate(), \" 1: Line one\\n    ^\\n 2: \\n 3: Line three\\n    ^^^^^^\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:334:18\n    |\n334 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:349:14\n    |\n349 |     by_line: spans,\n    |              ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"Line one\\nLine two\\nLine three\";",
                "    let line_number_width = 5;",
                "    let spans = vec![",
                "        vec![",
                "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                "        ],",
                "        vec![",
                "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                "        ],",
                "        vec![",
                "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                "        ],",
                "    ];",
                "",
                "    let mut spans_instance = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line: spans,",
                "        multi_line: vec![],",
                "    };",
                "",
                "    let _ = spans_instance.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.pattern, pattern);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.line_number_width, line_number_width);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line.len(), spans.len());"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line[0].len(), spans[0].len());"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line[1].len(), spans[1].len());"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line[2].len(), spans[2].len());"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert!(spans_instance.by_line[0][0].start.column < spans_instance.by_line[0][0].end.column);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert!(spans_instance.by_line[1][0].start.column < spans_instance.by_line[1][0].end.column);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert!(spans_instance.by_line[2][0].start.column < spans_instance.by_line[2][0].end.column);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.notate().contains(\"Line one\"), true);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.notate().contains(\"Line two\"), true);"
                ],
                [
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.notate().contains(\"Line three\"), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.pattern, pattern);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.line_number_width, line_number_width);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line.len(), spans.len());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line[0].len(), spans[0].len());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line[1].len(), spans[1].len());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.by_line[2].len(), spans[2].len());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert!(spans_instance.by_line[0][0].start.column < spans_instance.by_line[0][0].end.column);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert!(spans_instance.by_line[1][0].start.column < spans_instance.by_line[1][0].end.column);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert!(spans_instance.by_line[2][0].start.column < spans_instance.by_line[2][0].end.column);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.notate().contains(\"Line one\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.notate().contains(\"Line two\"), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "            ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "        ],",
                  "        vec![",
                  "            ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "        ],",
                  "    ];",
                  "",
                  "    let mut spans_instance = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line: spans,",
                  "        multi_line: vec![],",
                  "    };",
                  "",
                  "    let _ = spans_instance.notate();",
                  "    let pattern = \"Line one\\nLine two\\nLine three\";",
                  "    let line_number_width = 5;",
                  "    let spans = vec![",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 3 } },",
                  "    ast::Span { start: Position { column: 4 }, end: Position { column: 6 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 7 } },",
                  "    ],",
                  "    vec![",
                  "    ast::Span { start: Position { column: 1 }, end: Position { column: 8 } },",
                  "    ],",
                  "    ];",
                  "    assert_eq!(spans_instance.notate().contains(\"Line three\"), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for struct `Vec<Span>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/error.rs:360:58\n    |\n309 |     pub struct Span {\n    |     --------------- doesn't satisfy `llmtests::ast::Span: Sized`\n...\n360 |     assert_eq!(spans_instance.by_line[0].len(), spans[0].len());\n    |                                                          ^^^ private field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `{type error}: Sized`\n            which is required by `llmtests::ast::Span: Sized`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for struct `Vec<Span>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/error.rs:360:58\n    |\n309 |     pub struct Span {\n    |     --------------- doesn't satisfy `llmtests::ast::Span: Sized`\n...\n360 |     assert_eq!(spans_instance.by_line[1].len(), spans[1].len());\n    |                                                          ^^^ private field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `{type error}: Sized`\n            which is required by `llmtests::ast::Span: Sized`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for struct `Vec<Span>`, but its trait bounds were not satisfied\n   --> regex-syntax/src/error.rs:360:58\n    |\n309 |     pub struct Span {\n    |     --------------- doesn't satisfy `llmtests::ast::Span: Sized`\n...\n360 |     assert_eq!(spans_instance.by_line[2].len(), spans[2].len());\n    |                                                          ^^^ private field, not a method\n    |\n    = note: the following trait bounds were not satisfied:\n            `{type error}: Sized`\n            which is required by `llmtests::ast::Span: Sized`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:310:20\n    |\n310 |         pub start: Position,\n    |                    ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nerror[E0412]: cannot find type `Position` in this scope\n   --> regex-syntax/src/error.rs:311:18\n    |\n311 |         pub end: Position,\n    |                  ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n308 +     use ast::Position;\n    |\n308 +     use error::llmtests::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/error.rs:341:18\n    |\n341 |         by_line: spans,\n    |                  ^^^^^ expected `ast::Span`, found `llmtests::ast::Span`\n    |\n    = note: `llmtests::ast::Span` and `ast::Span` have similar names, but are actually distinct types\nnote: `llmtests::ast::Span` is defined in module `crate::error::llmtests::ast` of the current crate\n   --> regex-syntax/src/error.rs:309:5\n    |\n309 |     pub struct Span {\n    |     ^^^^^^^^^^^^^^^\nnote: `ast::Span` is defined in module `crate::ast` of the current crate\n   --> regex-syntax/src/ast/mod.rs:333:1\n    |\n333 | pub struct Span {\n    | ^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0412, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: (i, line) in self.pattern.lines().enumerate() is true\n",
        "// constraint: self.line_number_width > 0 is false, with bound self.line_number_width == 0\n",
        "// constraint: let Some(notes) = self.notate_line(i) is true\n",
        "// constraint: (i, line) in self.pattern.lines().enumerate() is false\n",
        "// expected return value/type: notated\n"
      ],
      "input_infer": "pattern: \"\", line_number_width: 0, by_line: [[]], multi_line: [] \n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"\";",
                "    let line_number_width = 0;",
                "    let by_line = vec![vec![]];",
                "    let multi_line = vec![];",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let line_number_width = 0;",
                "    let by_line = vec![vec![]];",
                "    let multi_line = vec![];",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"abc\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"abc\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\";",
                "    let line_number_width = 0;",
                "    let by_line = vec![vec![], vec![]];",
                "    let multi_line = vec![];",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    abc\\n    def\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n  \\n2: def\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"test\\ncase\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: test\\n  \\n2: case\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"test\\ncase\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 5;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    1: test\\n    ^^^^\\n    2: case\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"test\\ncase\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 5;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"one\\ntwo\\nthree\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    one\\n    ^^\\n    two\\n    three\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    abc\\n    def\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n  \\n2: def\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"test\\ncase\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: test\\n  \\n2: case\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"test\\ncase\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 5;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    1: test\\n    ^^^^\\n    2: case\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"test\\ncase\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let line_number_width = 5;",
                  "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    let pattern = \"one\\ntwo\\nthree\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    one\\n    ^^\\n    two\\n    three\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:330:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n330 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:43\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:81\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:330:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n330 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:43\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:81\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:340:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n340 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:340:43\n    |\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:340:81\n    |\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:330:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n330 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:43\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:81\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:340:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n340 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:340:43\n    |\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:340:81\n    |\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:349:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n349 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n349 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:349:43\n    |\n349 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:349:81\n    |\n349 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:330:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n330 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:43\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:330:81\n    |\n330 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:340:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n340 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:340:43\n    |\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:340:81\n    |\n340 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:349:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n349 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n349 |     let by_line = vec![vec![Spans { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:349:43\n    |\n349 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                                           ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:349:81\n    |\n349 |     let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];\n    |                                                                                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:359:37\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n359 |     let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];\n    |                                     ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n359 |     let by_line = vec![vec![], vec![Spans { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];\n    |                                     ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:359:51\n    |\n359 |     let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];\n    |                                                   ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n   --> regex-syntax/src/error.rs:359:89\n    |\n359 |     let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];\n    |                                                                                         ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let line_number_width = 2;",
                "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
                "    let multi_line = vec![];",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n  \\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n  \\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:307:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n307 |     let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n307 |     let by_line = vec![vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:307:43\n    |\n307 |     let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                                           ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:307:69\n    |\n307 |     let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                                                                     ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:320:29\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n320 |     let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                             ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n320 |     let by_line = vec![vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                             ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:320:43\n    |\n320 |     let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                                           ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:320:69\n    |\n320 |     let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];\n    |                                                                     ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\\ndef\";",
                "    let line_number_width = 3;",
                "    let by_line = vec![",
                "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                "    ];",
                "    let multi_line = vec![];",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"  1: abc\\n  ^\\n  2: def\\n  ^\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"abc\\n  ^\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"  1: \\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \" 1: abc\\n  ^^^\\n 2: def\\n\");"
                ],
                [
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"hello\\nworld\";",
                  "    let line_number_width = 4;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"   1: hello\\n   ^ ^ ^ ^ ^\\n   2: world\\n   ^ ^ ^ ^ ^\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"  1: abc\\n  ^\\n  2: def\\n  ^\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"abc\\n  ^\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"  1: \\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \" 1: abc\\n  ^^^\\n 2: def\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 0;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"\";",
                  "    let line_number_width = 3;",
                  "    let by_line = vec![",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"abc\\ndef\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
                  "    vec![],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    let pattern = \"hello\\nworld\";",
                  "    let line_number_width = 4;",
                  "    let by_line = vec![",
                  "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],",
                  "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],",
                  "    ];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans {",
                  "    pattern,",
                  "    line_number_width,",
                  "    by_line,",
                  "    multi_line,",
                  "    };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"   1: hello\\n   ^ ^ ^ ^ ^\\n   2: world\\n   ^ ^ ^ ^ ^\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n308 |         vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:28\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:54\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:309:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n309 |         vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:28\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:54\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:324:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n324 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:24\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:50\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:325:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n325 |     vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:24\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:50\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n308 |         vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:28\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:54\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:309:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n309 |         vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:28\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:54\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:324:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n324 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:24\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:50\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:325:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n325 |     vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:24\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:50\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:338:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n338 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:24\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:50\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n308 |         vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:28\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:54\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:309:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n309 |         vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:28\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:54\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:324:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n324 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:24\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:50\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:325:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n325 |     vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:24\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:50\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:338:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n338 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:24\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:50\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n308 |         vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:28\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:54\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:309:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n309 |         vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:28\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:54\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:324:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n324 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:24\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:50\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:325:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n325 |     vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:24\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:50\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:338:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n338 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:24\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:50\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:364:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n364 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n364 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:364:24\n    |\n364 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:364:50\n    |\n364 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:308:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n308 |         vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:28\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:308:54\n    |\n308 |         vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:309:14\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n309 |         vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |              ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:28\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                            ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:309:54\n    |\n309 |         vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                      ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:324:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n324 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:24\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:324:50\n    |\n324 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:325:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n325 |     vec![Spans { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:24\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:325:50\n    |\n325 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:338:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n338 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:24\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:338:50\n    |\n338 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:364:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n364 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n364 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:364:24\n    |\n364 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:364:50\n    |\n364 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:378:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n378 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n378 |     vec![Spans { start: Position::new(0, 1), end: Position::new(0, 5) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:378:24\n    |\n378 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:378:50\n    |\n378 |     vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/error.rs:379:10\n    |\n144 | struct Spans<'p> {\n    | ---------------- similarly named struct `Spans` defined here\n...\n379 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],\n    |          ^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n379 |     vec![Spans { start: Position::new(1, 1), end: Position::new(1, 5) }],\n    |          ~~~~~\nhelp: consider importing this struct\n    |\n300 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:379:24\n    |\n379 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],\n    |                        ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n   --> regex-syntax/src/error.rs:379:50\n    |\n379 |     vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],\n    |                                                  ^^^^^^^^ use of undeclared type `Position`\n    |\nhelp: consider importing this struct\n    |\n300 +    use ast::Position;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \"abc\";",
                "    let line_number_width = 2;",
                "    let by_line = vec![vec![]];",
                "    let multi_line = vec![];",
                "",
                "    let spans = Spans {",
                "        pattern,",
                "        line_number_width,",
                "        by_line,",
                "        multi_line,",
                "    };",
                "",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n\");"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert!(result.contains(\"abc\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert!(result.starts_with(\" 1:\"));"
                ],
                [
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert!(result.ends_with(\"\\n\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n\");",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert!(result.contains(\"abc\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert!(result.starts_with(\" 1:\"));",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "",
                  "    let spans = Spans {",
                  "        pattern,",
                  "        line_number_width,",
                  "        by_line,",
                  "        multi_line,",
                  "    };",
                  "",
                  "    spans.notate();",
                  "    let pattern = \"abc\";",
                  "    let line_number_width = 2;",
                  "    let by_line = vec![vec![]];",
                  "    let multi_line = vec![];",
                  "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
                  "    let result = spans.notate();",
                  "    assert!(result.ends_with(\"\\n\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: (i, line) in self.pattern.lines().enumerate() is false\n",
        "// expected return value/type: notated\n"
      ],
      "input_infer": "pattern: \"\" (empty string), line_number_width: 0; pattern: \"abc\" (single line), line_number_width: 0; pattern: \"abc\\ndef\" (two lines), line_number_width: 2; pattern: \"line1\\nline2\\nline3\" (three lines), line_number_width: 3; pattern: \"line1\\nline2\" (two lines), line_number_width: 1; pattern: \"line1\\nline2\\nline3\\nline4\\nline5\" (five lines), line_number_width: 5; pattern: \"line\\nline\\nline\\nline\" (four lines), line_number_width: 4; pattern: \"a\\nb\\nc\" (three lines), line_number_width: 6; pattern: \"1\\n2\" (two lines), line_number_width: 0.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"\",",
                "        line_number_width: 0,",
                "        by_line: vec![vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans {",
                  "    pattern: \"\",",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"\",",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans {",
                  "    pattern: \"\",",
                  "    line_number_width: 0,",
                  "    by_line: vec![vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"abc\",",
                "        line_number_width: 0,",
                "        by_line: vec![vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans { pattern: \"abc\", line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"    abc\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"abc\",",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans { pattern: \"abc\", line_number_width: 0, by_line: vec![vec![]], multi_line: vec![] };",
                  "    let notated = spans.notate();",
                  "    assert_eq!(notated, \"    abc\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"abc\\ndef\",",
                "        line_number_width: 2,",
                "        by_line: vec![vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans { pattern: \"abc\\ndef\", line_number_width: 2, by_line: vec![vec![], vec![]], multi_line: vec![] };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n 2: def\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"abc\\ndef\",",
                  "        line_number_width: 2,",
                  "        by_line: vec![vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans { pattern: \"abc\\ndef\", line_number_width: 2, by_line: vec![vec![], vec![]], multi_line: vec![] };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: abc\\n 2: def\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"line1\\nline2\\nline3\",",
                "        line_number_width: 3,",
                "        by_line: vec![vec![], vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans { pattern: \"line1\\nline2\\nline3\", line_number_width: 3, by_line: vec![vec![], vec![], vec![]], multi_line: vec![] };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"  1: line1\\n  2: line2\\n  3: line3\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"line1\\nline2\\nline3\",",
                  "        line_number_width: 3,",
                  "        by_line: vec![vec![], vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans { pattern: \"line1\\nline2\\nline3\", line_number_width: 3, by_line: vec![vec![], vec![], vec![]], multi_line: vec![] };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"  1: line1\\n  2: line2\\n  3: line3\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"line1\\nline2\",",
                "        line_number_width: 1,",
                "        by_line: vec![vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans {",
                  "    pattern: \"line1\\nline2\",",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![], vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: line1\\n 2: line2\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"line1\\nline2\",",
                  "        line_number_width: 1,",
                  "        by_line: vec![vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans {",
                  "    pattern: \"line1\\nline2\",",
                  "    line_number_width: 1,",
                  "    by_line: vec![vec![], vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \" 1: line1\\n 2: line2\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"line1\\nline2\\nline3\\nline4\\nline5\",",
                "        line_number_width: 5,",
                "        by_line: vec![vec![], vec![], vec![], vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans {",
                  "    pattern: \"line1\\nline2\\nline3\\nline4\\nline5\",",
                  "    line_number_width: 5,",
                  "    by_line: vec![vec![], vec![], vec![], vec![], vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    1: line1\\n    2: line2\\n    3: line3\\n    4: line4\\n    5: line5\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"line1\\nline2\\nline3\\nline4\\nline5\",",
                  "        line_number_width: 5,",
                  "        by_line: vec![vec![], vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans {",
                  "    pattern: \"line1\\nline2\\nline3\\nline4\\nline5\",",
                  "    line_number_width: 5,",
                  "    by_line: vec![vec![], vec![], vec![], vec![], vec![]],",
                  "    multi_line: vec![],",
                  "    };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"    1: line1\\n    2: line2\\n    3: line3\\n    4: line4\\n    5: line5\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"line\\nline\\nline\\nline\",",
                "        line_number_width: 4,",
                "        by_line: vec![vec![], vec![], vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans { pattern: \"line\\nline\\nline\\nline\", line_number_width: 4, by_line: vec![vec![], vec![], vec![], vec![]], multi_line: vec![] };",
                  "    assert_eq!(spans.notate(), \"   1: line\\n   2: line\\n   3: line\\n   4: line\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"line\\nline\\nline\\nline\",",
                  "        line_number_width: 4,",
                  "        by_line: vec![vec![], vec![], vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans { pattern: \"line\\nline\\nline\\nline\", line_number_width: 4, by_line: vec![vec![], vec![], vec![], vec![]], multi_line: vec![] };",
                  "    assert_eq!(spans.notate(), \"   1: line\\n   2: line\\n   3: line\\n   4: line\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"a\\nb\\nc\",",
                "        line_number_width: 6,",
                "        by_line: vec![vec![], vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans { pattern: \"a\\nb\\nc\", line_number_width: 6, by_line: vec![vec![], vec![], vec![]], multi_line: vec![] };",
                  "    assert_eq!(spans.notate(), \"     1: a\\n     2: b\\n     3: c\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"a\\nb\\nc\",",
                  "        line_number_width: 6,",
                  "        by_line: vec![vec![], vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans { pattern: \"a\\nb\\nc\", line_number_width: 6, by_line: vec![vec![], vec![], vec![]], multi_line: vec![] };",
                  "    assert_eq!(spans.notate(), \"     1: a\\n     2: b\\n     3: c\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let spans = Spans {",
                "        pattern: \"1\\n2\",",
                "        line_number_width: 0,",
                "        by_line: vec![vec![], vec![]],",
                "        multi_line: vec![],",
                "    };",
                "    spans.notate();",
                "}"
              ],
              "oracles": [
                [
                  "    let spans = Spans { pattern: \"1\\n2\", line_number_width: 0, by_line: vec![vec![], vec![]], multi_line: vec![] };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"1\\n2\\n\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let spans = Spans {",
                  "        pattern: \"1\\n2\",",
                  "        line_number_width: 0,",
                  "        by_line: vec![vec![], vec![]],",
                  "        multi_line: vec![],",
                  "    };",
                  "    spans.notate();",
                  "    let spans = Spans { pattern: \"1\\n2\", line_number_width: 0, by_line: vec![vec![], vec![]], multi_line: vec![] };",
                  "    let result = spans.notate();",
                  "    assert_eq!(result, \"1\\n2\\n\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/error.rs:301:8\n    |\n301 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}