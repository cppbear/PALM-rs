{
  "name": "regex_syntax::hir::translate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_post",
  "name_with_impl": "regex_syntax::hir::translate::{impl#4}::visit_post",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:29:1:29:19"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/translate.rs:283:5:369:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "1 <= ast.length <= 10, 1 <= exprs.count <= 10, 1 <= exprs[*].kind <= 10, 1 <= self.pop().count <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator::default();",
                "    let pattern = \"ab|cd\";",
                "    let mut visitor = TranslatorI::new(&translator, pattern);",
                "    ",
                "    let span = Span { start: 0, end: 2 };",
                "    let ast_concat = Ast::Concat(vec![",
                "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                "    ]);",
                "    ",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    ",
                "    let result = visitor.visit_post(&ast_concat);",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    let hir_frame = visitor.pop().unwrap();",
                  "    assert!(matches!(hir_frame, HirFrame::Expr(_)));"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    let hir_frame = visitor.pop().unwrap();",
                  "    let hir_frame = visitor.pop().unwrap();",
                  "    assert!(matches!(hir_frame, HirFrame::Expr(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    let hir_frame = visitor.pop().unwrap();",
                  "    assert!(matches!(hir_frame, HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"ab|cd\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 2 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    let hir_frame = visitor.pop().unwrap();",
                  "    let hir_frame = visitor.pop().unwrap();",
                  "    assert!(matches!(hir_frame, HirFrame::Expr(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:22\n     |\n2546 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:44\n     |\n2546 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:22\n     |\n2547 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:18\n     |\n2560 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2560:40\n     |\n2560 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:18\n     |\n2561 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:40\n     |\n2561 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n2547 | |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2560 | |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n2561 | |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n2562 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:22\n     |\n2546 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:44\n     |\n2546 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:22\n     |\n2547 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:18\n     |\n2560 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2560:40\n     |\n2560 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:18\n     |\n2561 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:40\n     |\n2561 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n2547 | |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2560 | |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n2561 | |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n2562 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:22\n     |\n2546 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:44\n     |\n2546 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:22\n     |\n2547 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:44\n     |\n2547 |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:18\n     |\n2560 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2560:40\n     |\n2560 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n     |                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:18\n     |\n2561 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:40\n     |\n2561 |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n     |                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n2547 | |         Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2560 | |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'a' }),\n2561 | |     Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'b' })\n2562 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator::default();",
                "    let pattern = \"x{3,5}|y?\";",
                "    let mut visitor = TranslatorI::new(&translator, pattern);",
                "    ",
                "    let span = Span { start: 0, end: 5 };",
                "    let ast_concat = Ast::Concat(vec![",
                "        Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                "        Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                "    ]);",
                "    ",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    ",
                "    let result = visitor.visit_post(&ast_concat);",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {",
                  "    assert!(expr.kind().is_empty() == false);"
                ],
                [
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {",
                  "    exprs.push(expr);",
                  "    }",
                  "    assert_eq!(exprs.len(), 2);"
                ],
                [
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {",
                  "    exprs.push(expr);",
                  "    }",
                  "    exprs.reverse();",
                  "    let hir_concat = Hir::concat(exprs);",
                  "    assert!(matches!(self.pop(), Some(HirFrame::Expr(hir_concat))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "        Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {",
                  "    assert!(expr.kind().is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "        Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {",
                  "    exprs.push(expr);",
                  "    }",
                  "    assert_eq!(exprs.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "        Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let pattern = \"x{3,5}|y?\";",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),",
                  "    Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })",
                  "    ]);",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {",
                  "    exprs.push(expr);",
                  "    }",
                  "    exprs.reverse();",
                  "    let hir_concat = Hir::concat(exprs);",
                  "    assert!(matches!(self.pop(), Some(HirFrame::Expr(hir_concat))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2564:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2564 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Litera...\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Litera...\n     |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n    --> regex-syntax/src/hir/translate.rs:2546:68\n     |\n2546 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Litera...\n     |                                                                  ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::RepetitionRange;\n     |\n2535 +    use hir::RepetitionRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:142\n     |\n2546 | ...d(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:164\n     |\n2546 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Lite...\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Lite...\n     |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:114\n     |\n2547 | ...eroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:136\n     |\n2547 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:21\n     |\n2557 |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n     |                     ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2557:44\n     |\n2557 |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n     |                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n    --> regex-syntax/src/hir/translate.rs:2557:64\n     |\n2557 |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n     |                                                                ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::RepetitionRange;\n     |\n2535 +    use hir::RepetitionRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:138\n     |\n2557 | ...d(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2557:160\n     |\n2557 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:21\n     |\n2558 |     Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Litera...\n     |                     ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2558:44\n     |\n2558 |     Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Litera...\n     |                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:110\n     |\n2558 | ...eroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2558:132\n     |\n2558 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2561:44\n     |\n2538 | fn test_visit_post_04()\n     |    ------------------ this function can't have a `self` parameter\n...\n2561 |     while let Some(HirFrame::Expr(expr)) = self.pop() {\n     |                                            ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Lite...\n2547 | |         Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Li...\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:34\n     |\n2556 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2557 | |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n2558 | |     Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Litera...\n2559 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0424, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Litera...\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Litera...\n     |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n    --> regex-syntax/src/hir/translate.rs:2546:68\n     |\n2546 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Litera...\n     |                                                                  ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::RepetitionRange;\n     |\n2535 +    use hir::RepetitionRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:142\n     |\n2546 | ...d(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:164\n     |\n2546 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Lite...\n     |                       ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 | ...   Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Lite...\n     |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:114\n     |\n2547 | ...eroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:136\n     |\n2547 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:21\n     |\n2557 |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n     |                     ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2557:44\n     |\n2557 |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n     |                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionRange`\n    --> regex-syntax/src/hir/translate.rs:2557:64\n     |\n2557 |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n     |                                                                ^^^^^^^^^^^^^^^ use of undeclared type `RepetitionRange`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::RepetitionRange;\n     |\n2535 +    use hir::RepetitionRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:138\n     |\n2557 | ...d(3, 5)), greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2557:160\n     |\n2557 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'x' })) }),\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:21\n     |\n2558 |     Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Litera...\n     |                     ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2558:44\n     |\n2558 |     Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Litera...\n     |                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:110\n     |\n2558 | ...eroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2558:132\n     |\n2558 | ...ox::new(Ast::Literal(Literal { span, kind: LiteralKind::Char, c: 'y' })) })\n     |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2561:44\n     |\n2538 | fn test_visit_post_05()\n     |    ------------------ this function can't have a `self` parameter\n...\n2561 |     while let Some(HirFrame::Expr(expr)) = self.pop() {\n     |                                            ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2566:22\n     |\n2538 | fn test_visit_post_05()\n     |    ------------------ this function can't have a `self` parameter\n...\n2566 |     assert!(matches!(self.pop(), Some(HirFrame::Expr(hir_concat))));\n     |                      ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Lite...\n2547 | |         Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Li...\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:34\n     |\n2556 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2557 | |     Ast::Repetition(Repetition { span, op: RepetitionOp::Range(RepetitionRange::Bounded(3, 5)), greedy: true, ast: Box::new(Ast::Literal(...\n2558 | |     Ast::Repetition(Repetition { span, op: RepetitionOp::ZeroOrOne, greedy: true, ast: Box::new(Ast::Literal(Literal { span, kind: Litera...\n2559 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0424, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator::default();",
                "    let pattern = \"(?:)\";",
                "    let mut visitor = TranslatorI::new(&translator, pattern);",
                "    ",
                "    let span = Span { start: 0, end: 1 };",
                "    let ast_concat = Ast::Concat(vec![",
                "        Ast::Empty(span),",
                "        Ast::Empty(span)",
                "    ]);",
                "    ",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    ",
                "    let result = visitor.visit_post(&ast_concat);",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Concat(vec![]));"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(visitor.pop().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Empty(span),",
                  "        Ast::Empty(span)",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Empty(span),",
                  "        Ast::Empty(span)",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Concat(vec![]));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Empty(span),",
                  "        Ast::Empty(span)",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Empty(span),",
                  "        Ast::Empty(span)",
                  "    ]);",
                  "    ",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"(?:)\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Empty(span),\n2547 | |         Ast::Empty(span)\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |     let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);\n     |                      ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |                      |\n     |                      arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Concat(vec![]));\n     |                                                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Empty(span),\n2547 | |         Ast::Empty(span)\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |     let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);\n     |                      ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |                      |\n     |                      arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);\n     |                                                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Empty(span),\n2547 | |         Ast::Empty(span)\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |     let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);\n     |                      ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |                      |\n     |                      arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:30\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:38\n     |\n2544 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n2545 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2546 | |         Ast::Empty(span),\n2547 | |         Ast::Empty(span)\n2548 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2555 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:34\n     |\n2559 |     let ast_concat = Ast::Concat(vec![Ast::Empty(span), Ast::Empty(span)]);\n     |                      ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |                      |\n     |                      arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator::default();",
                "    let pattern = \"a|b|c\";",
                "    let mut visitor = TranslatorI::new(&translator, pattern);",
                "    ",
                "    let span_a = Span { start: 0, end: 1 };",
                "    let span_b = Span { start: 1, end: 2 };",
                "    let span_c = Span { start: 2, end: 3 };",
                "    ",
                "    let ast_concat = Ast::Concat(vec![",
                "        Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                "        Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                "        Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                "    ]);",
                "",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    visitor.push(HirFrame::Expr(Hir::empty()));",
                "    ",
                "    let result = visitor.visit_post(&ast_concat);",
                "    assert!(result.is_ok());",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Concat(vec![]));"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(visitor.pop().is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    ",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "        Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    ",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "        Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    ",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "        Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Concat(vec![]));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    ",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    ",
                  "    let ast_concat = Ast::Concat(vec![",
                  "        Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "        Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "        Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    ",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(result.is_ok());",
                  "    let mut translator = Translator::default();",
                  "    let pattern = \"a|b|c\";",
                  "    let mut visitor = TranslatorI::new(&translator, pattern);",
                  "    let span_a = Span { start: 0, end: 1 };",
                  "    let span_b = Span { start: 1, end: 2 };",
                  "    let span_c = Span { start: 2, end: 3 };",
                  "    let ast_concat = Ast::Concat(vec![",
                  "    Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),",
                  "    Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),",
                  "    Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })",
                  "    ]);",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    visitor.push(HirFrame::Expr(Hir::empty()));",
                  "    let result = visitor.visit_post(&ast_concat);",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:22\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:22\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2550:52\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:22\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:48\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:18\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2568:48\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:18\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2569:48\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:40\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:40\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:34\n     |\n2548 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2549 | |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2550 | |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2551 | |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2552 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:32\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:40\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:40\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:40\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:34\n     |\n2566 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2567 | |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2568 | |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2569 | |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2570 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:22\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:22\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2550:52\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:22\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:48\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:18\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2568:48\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:18\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2569:48\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:40\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:40\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:34\n     |\n2548 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2549 | |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2550 | |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2551 | |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2552 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:32\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:40\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:40\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:40\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:34\n     |\n2566 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2567 | |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2568 | |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2569 | |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2570 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:22\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:22\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2550:52\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:22\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:48\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:18\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2568:48\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:18\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2569:48\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2575:41\n     |\n2575 |     assert_eq!(result.unwrap().kind(), &HirKind::Concat(vec![]));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:40\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:40\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:34\n     |\n2548 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2549 | |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2550 | |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2551 | |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2552 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:32\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:40\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:40\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:40\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:34\n     |\n2566 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2567 | |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2568 | |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2569 | |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2570 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no method named `kind` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2575:32\n     |\n2575 |     assert_eq!(result.unwrap().kind(), &HirKind::Concat(vec![]));\n     |                                ^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:22\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:22\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2550:52\n     |\n2550 |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:22\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                      ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:18\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:48\n     |\n2567 |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:18\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2568:48\n     |\n2568 |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:18\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                  ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2569:48\n     |\n2569 |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n     |                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:32\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:40\n     |\n2544 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:40\n     |\n2545 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:32\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:34\n     |\n2548 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2549 | |         Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2550 | |         Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2551 | |         Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2552 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2560 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:32\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:40\n     |\n2563 |     let span_a = Span { start: 0, end: 1 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:32\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:40\n     |\n2564 |     let span_b = Span { start: 1, end: 2 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:32\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:40\n     |\n2565 |     let span_c = Span { start: 2, end: 3 };\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:34\n     |\n2566 |       let ast_concat = Ast::Concat(vec![\n     |  ______________________-----------_^\n     | |                      |\n     | |                      arguments to this enum variant are incorrect\n2567 | |     Ast::Literal(Literal { span: span_a, kind: LiteralKind::Char, c: 'a' }),\n2568 | |     Ast::Literal(Literal { span: span_b, kind: LiteralKind::Char, c: 'b' }),\n2569 | |     Ast::Literal(Literal { span: span_c, kind: LiteralKind::Char, c: 'c' })\n2570 | |     ]);\n     | |_____^ expected `Concat`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is false\n",
        "// constraint: expr.kind().is_empty() is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Concat(vec![Ast::Empty(Span { start: 0, end: 0 }), Ast::Literal(Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'a' })]), Ast::Concat(vec![Ast::Empty(Span { start: 0, end: 0 }), Ast::Repetition(Repetition { span: Span { start: 0, end: 0 }, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' })) })])]), Ast::Concat(vec![Ast::Empty(Span { start: 0, end: 0 })]), Ast::Concat(vec![Ast::Literal(Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Character, c: 'c' })]);\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span_empty = Span { start: 0, end: 0 };",
                "    let span_literal = Span { start: 0, end: 1 };",
                "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.push(HirFrame::Expr(Hir::empty()));",
                  "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_empty());"
                ],
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.push(HirFrame::Expr(Hir::empty()));",
                  "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    assert!(translator.pop().is_some());"
                ],
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.push(HirFrame::Expr(Hir::empty()));",
                  "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    assert!(translator.visit_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.push(HirFrame::Expr(Hir::empty()));",
                  "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.push(HirFrame::Expr(Hir::empty()));",
                  "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    assert!(translator.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_literal = Span { start: 0, end: 1 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.push(HirFrame::Expr(Hir::empty()));",
                  "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    assert!(translator.visit_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:51\n     |\n2542 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:51\n     |\n2548 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:38\n     |\n2541 |     let span_literal = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:46\n     |\n2541 |     let span_literal = Span { start: 0, end: 1 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:27\n     |\n2543 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:36\n     |\n2546 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:44\n     |\n2546 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span_literal = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let span_literal = Span { start: 0, end: 1 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2550 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:51\n     |\n2542 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:51\n     |\n2548 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:38\n     |\n2541 |     let span_literal = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:46\n     |\n2541 |     let span_literal = Span { start: 0, end: 1 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:27\n     |\n2543 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:36\n     |\n2546 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:44\n     |\n2546 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span_literal = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let span_literal = Span { start: 0, end: 1 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2550 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:51\n     |\n2542 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:51\n     |\n2548 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:38\n     |\n2541 |     let span_literal = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:46\n     |\n2541 |     let span_literal = Span { start: 0, end: 1 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:27\n     |\n2543 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:36\n     |\n2546 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:44\n     |\n2546 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span_literal = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let span_literal = Span { start: 0, end: 1 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:27\n     |\n2549 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2550 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span_empty = Span { start: 0, end: 0 };",
                "    let span_repetition = Span { start: 0, end: 0 };",
                "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
                "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
                "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    assert_eq!(translator.pop().is_some(), true);"
                ],
                [
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    assert_eq!(frame.is_none(), false);"
                ],
                [
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    let expr = frame.unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind().is_empty(), true);"
                ],
                [
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    let expr = frame.unwrap().unwrap_expr();",
                  "    assert_eq!(translator.pop().is_some(), true);"
                ],
                [
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    let expr = frame.unwrap().unwrap_expr();",
                  "    assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_repetition = Span { start: 0, end: 0 };",
                  "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
                  "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    assert_eq!(translator.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_repetition = Span { start: 0, end: 0 };",
                  "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
                  "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    assert_eq!(frame.is_none(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_repetition = Span { start: 0, end: 0 };",
                  "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
                  "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    let expr = frame.unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind().is_empty(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_repetition = Span { start: 0, end: 0 };",
                  "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
                  "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    let expr = frame.unwrap().unwrap_expr();",
                  "    assert_eq!(translator.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let span_repetition = Span { start: 0, end: 0 };",
                  "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
                  "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
                  "    let exprs = vec![Hir::empty()];",
                  "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
                  "    let frame = translator.pop();",
                  "    let expr = frame.unwrap().unwrap_expr();",
                  "    assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:64\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2543:55\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:41\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:49\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:45\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:53\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:27\n     |\n2548 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:64\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2543:55\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:41\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:49\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:45\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:53\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:27\n     |\n2548 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:64\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2543:55\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:41\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:49\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:45\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:53\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:27\n     |\n2548 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:64\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2543:55\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:41\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:49\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:45\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:53\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:27\n     |\n2548 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:15\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2542:64\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                                ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |               ^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Repetition;\n     |\n2535 +    use hir::HirKind::Repetition;\n     |\n2535 +    use hir::Repetition;\n     |\n2535 +    use hir::translate::Ast::Repetition;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2543:55\n     |\n2543 |     let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };\n     |                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::RepetitionOp;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:41\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:49\n     |\n2541 |     let span_repetition = Span { start: 0, end: 0 };\n     |                                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:45\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:53\n     |\n2542 |     let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:27\n     |\n2544 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2547 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:27\n     |\n2548 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:54\n     |\n2553 |     assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));\n     |                                                      ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span_empty = Span { start: 0, end: 0 };",
                "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert_eq!(translator.pop().is_none(), false);"
                ],
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert_eq!(translator.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);"
                ],
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert_eq!(translator.pop().is_none(), true);"
                ],
                [
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert!(translator.visit_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert_eq!(translator.pop().is_none(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert_eq!(translator.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert_eq!(translator.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_empty = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    assert!(translator.visit_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:27\n     |\n2541 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2542 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:36\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:44\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:27\n     |\n2545 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2546 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2547:65\n     |\n2547 |     assert_eq!(translator.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);\n     |                                                                 ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:27\n     |\n2541 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2542 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:36\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:44\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:27\n     |\n2545 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2546 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:27\n     |\n2541 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2542 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:36\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:44\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:27\n     |\n2545 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2546 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:36\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:44\n     |\n2540 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:27\n     |\n2541 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2542 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:36\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2544:44\n     |\n2544 |     let span_empty = Span { start: 0, end: 0 };\n     |                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:27\n     |\n2545 |     let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2546 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span_literal = Span { start: 1, end: 2 };",
                "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.pop().is_some());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.pop().is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.pop().is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.trans().stack.borrow().last(), Some(HirFrame::Expr(_))));"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().case_insensitive.is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().multi_line.is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().dot_matches_new_line.is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().swap_greed.is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().unicode.is_none());"
                ],
                [
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.pop(), None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.trans().stack.borrow().last(), Some(HirFrame::Expr(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().case_insensitive.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().multi_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().dot_matches_new_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().swap_greed.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(translator.trans().flags.get().unicode.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span_literal = Span { start: 1, end: 2 };",
                  "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
                  "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.pop(), None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:15\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2541:51\n     |\n2541 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:15\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |               ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2546:51\n     |\n2546 |     let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };\n     |                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:46\n     |\n2540 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2543 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:38\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:46\n     |\n2545 |     let span_literal = Span { start: 1, end: 2 };\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:27\n     |\n2547 |     let ast = Ast::Concat(vec![Ast::Literal(lit)]);\n     |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2548 |     let mut translator = TranslatorI::new(&Translator::default(), \"\");\n     |                                                        ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is false\n",
        "// constraint: expr.kind().is_empty() is false\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Test input ranges: Ast::Concat containing multiple non-empty expressions where at least one element has an empty kind, and at least one valid HirFrame to pop.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                "",
                "    let span = Span { start: 0, end: 5 };",
                "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                "    let expr3 = Hir::empty();",
                "",
                "    visitor.push(HirFrame::Expr(expr2)); ",
                "    visitor.push(HirFrame::Expr(expr1)); ",
                "    visitor.push(HirFrame::Expr(expr3)); ",
                "",
                "    let ast = Ast::Concat(vec![]); ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_none(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.stack.borrow().len(), 1); // After visiting Ast::Concat, one expr remains"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.stack.borrow().get(0).unwrap().unwrap_expr(), expr1); // The remaining expression is expr1"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.visit_post(&ast).is_ok(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.stack.borrow().len(), 1); // After visiting Ast::Concat, one expr remains",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.stack.borrow().get(0).unwrap().unwrap_expr(), expr1); // The remaining expression is expr1",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });",
                  "    let expr3 = Hir::empty();",
                  "    visitor.push(HirFrame::Expr(expr2));",
                  "    visitor.push(HirFrame::Expr(expr1));",
                  "    visitor.push(HirFrame::Expr(expr3));",
                  "    assert_eq!(visitor.visit_post(&ast).is_ok(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2570:24\n     |\n2570 |     assert_eq!(visitor.stack.borrow().len(), 1); // After visiting Ast::Concat, one expr remains\n     |                        ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2570 |     assert_eq!(visitor.trans.stack.borrow().len(), 1); // After visiting Ast::Concat, one expr remains\n     |                        ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2570:24\n     |\n2570 |     assert_eq!(visitor.stack.borrow().get(0).unwrap().unwrap_expr(), expr1); // The remaining expression is expr1\n     |                        ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2570 |     assert_eq!(visitor.trans.stack.borrow().get(0).unwrap().unwrap_expr(), expr1); // The remaining expression is expr1\n     |                        ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:52\n     |\n2564 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'a' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:52\n     |\n2565 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'b' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2563:38\n     |\n2563 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                "",
                "    let span = Span { start: 0, end: 5 };",
                "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });",
                "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });",
                "    let expr3 = Hir::empty();",
                "",
                "    visitor.push(HirFrame::Expr(expr3)); ",
                "    visitor.push(HirFrame::Expr(expr2)); ",
                "    visitor.push(HirFrame::Expr(expr1)); ",
                "",
                "    let ast = Ast::Concat(vec![]); ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    visitor.pop();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    visitor.pop();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(!expr.kind().is_empty());"
                ],
                [
                  "    visitor.pop();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    visitor.pop();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 0);"
                ],
                [
                  "    visitor.pop();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    visitor.pop();",
                  "    assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.pop();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.pop();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(!expr.kind().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.pop();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    visitor.pop();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });",
                  "    let expr3 = Hir::empty();",
                  "",
                  "    visitor.push(HirFrame::Expr(expr3)); ",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.pop();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    visitor.pop();",
                  "    assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'c' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'd' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:27\n     |\n2556 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:51\n     |\n2561 |     assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));\n     |                                                   ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                "",
                "    let span = Span { start: 0, end: 5 };",
                "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                "",
                "    visitor.push(HirFrame::Expr(expr2)); ",
                "    visitor.push(HirFrame::Expr(expr1)); ",
                "",
                "    let ast = Ast::Concat(vec![]); ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_none(), true);"
                ],
                [
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_none(), true);"
                ],
                [
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_some(), false);"
                ],
                [
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.visit_post(&ast).is_ok(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.pop().is_some(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });",
                  "    let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });",
                  "",
                  "    visitor.push(HirFrame::Expr(expr2)); ",
                  "    visitor.push(HirFrame::Expr(expr1)); ",
                  "",
                  "    let ast = Ast::Concat(vec![]); ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.push(HirFrame::Expr(Hir::concat(vec![expr1, expr2])));",
                  "    assert_eq!(visitor.visit_post(&ast).is_ok(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:27\n     |\n2554 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:27\n     |\n2554 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:27\n     |\n2554 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:27\n     |\n2554 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:27\n     |\n2554 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:52\n     |\n2548 |     let expr1 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'e' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                              ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |     let expr2 = Hir::literal(Literal { span, kind: LiteralKind::Unicode, c: 'f' });\n     |                                                    ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:27\n     |\n2554 |     let ast = Ast::Concat(vec![]); \n     |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Concat`\n                found struct `Vec<_>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:499:5\n     |\n499  |     Concat(Concat),\n     |     ^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(_) is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Alternation(vec![Ast::Group(Span { start: 0, end: 1 }), Ast::Class(ast::Class::Unicode(ClassUnicode { span: Span { start: 1, end: 2 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') }))]); let Some(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode { span: Span { start: 1, end: 2 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') })))); let Some(HirFrame::Expr(Hir::group(Group { span: Span { start: 0, end: 1 }, kind: GroupKind::NonCapturing, ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })) })));\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let ast = Ast::Alternation(vec![",
                "        Ast::Group(Group {",
                "            span: Span { start: 0, end: 1 },",
                "            kind: GroupKind::NonCapturing,",
                "            ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                "        }),",
                "        Ast::Class(ast::Class::Unicode(ClassUnicode {",
                "            span: Span { start: 1, end: 2 },",
                "            negated: false,",
                "            kind: ClassUnicodeKind::OneLetter('a'),",
                "        })),",
                "    ]);",
                "    ",
                "    translator.push(HirFrame::Expr(Hir::group(Group {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: GroupKind::NonCapturing,",
                "        ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                "    })));",
                "    translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {",
                "        span: Span { start: 1, end: 2 },",
                "        negated: false,",
                "        kind: ClassUnicodeKind::OneLetter('a'),",
                "    }))));",
                "    ",
                "    let result = translator.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    assert!(matches!(expr.kind(), HirKind::Alternation(_)));"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    let exprs = if let HirKind::Alternation(exprs) = expr.kind() {",
                  "    exprs",
                  "    } else {",
                  "    panic!(\"Expected expression kind to be Alternation\");",
                  "    };",
                  "    assert_eq!(exprs.len(), 2);"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    let exprs = if let HirKind::Alternation(exprs) = expr.kind() {",
                  "    exprs",
                  "    } else {",
                  "    panic!(\"Expected expression kind to be Alternation\");",
                  "    };",
                  "    assert!(matches!(exprs[0].kind(), HirKind::Group(_)));"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    let exprs = if let HirKind::Alternation(exprs) = expr.kind() {",
                  "    exprs",
                  "    } else {",
                  "    panic!(\"Expected expression kind to be Alternation\");",
                  "    };",
                  "    assert!(matches!(exprs[1].kind(), HirKind::Class(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(vec![",
                  "        Ast::Group(Group {",
                  "            span: Span { start: 0, end: 1 },",
                  "            kind: GroupKind::NonCapturing,",
                  "            ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "        }),",
                  "        Ast::Class(ast::Class::Unicode(ClassUnicode {",
                  "            span: Span { start: 1, end: 2 },",
                  "            negated: false,",
                  "            kind: ClassUnicodeKind::OneLetter('a'),",
                  "        })),",
                  "    ]);",
                  "    ",
                  "    translator.push(HirFrame::Expr(Hir::group(Group {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "    })));",
                  "    translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {",
                  "        span: Span { start: 1, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    }))));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(vec![",
                  "        Ast::Group(Group {",
                  "            span: Span { start: 0, end: 1 },",
                  "            kind: GroupKind::NonCapturing,",
                  "            ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "        }),",
                  "        Ast::Class(ast::Class::Unicode(ClassUnicode {",
                  "            span: Span { start: 1, end: 2 },",
                  "            negated: false,",
                  "            kind: ClassUnicodeKind::OneLetter('a'),",
                  "        })),",
                  "    ]);",
                  "    ",
                  "    translator.push(HirFrame::Expr(Hir::group(Group {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "    })));",
                  "    translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {",
                  "        span: Span { start: 1, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    }))));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    assert!(matches!(expr.kind(), HirKind::Alternation(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(vec![",
                  "        Ast::Group(Group {",
                  "            span: Span { start: 0, end: 1 },",
                  "            kind: GroupKind::NonCapturing,",
                  "            ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "        }),",
                  "        Ast::Class(ast::Class::Unicode(ClassUnicode {",
                  "            span: Span { start: 1, end: 2 },",
                  "            negated: false,",
                  "            kind: ClassUnicodeKind::OneLetter('a'),",
                  "        })),",
                  "    ]);",
                  "    ",
                  "    translator.push(HirFrame::Expr(Hir::group(Group {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "    })));",
                  "    translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {",
                  "        span: Span { start: 1, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    }))));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    let exprs = if let HirKind::Alternation(exprs) = expr.kind() {",
                  "    exprs",
                  "    } else {",
                  "    panic!(\"Expected expression kind to be Alternation\");",
                  "    };",
                  "    assert_eq!(exprs.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(vec![",
                  "        Ast::Group(Group {",
                  "            span: Span { start: 0, end: 1 },",
                  "            kind: GroupKind::NonCapturing,",
                  "            ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "        }),",
                  "        Ast::Class(ast::Class::Unicode(ClassUnicode {",
                  "            span: Span { start: 1, end: 2 },",
                  "            negated: false,",
                  "            kind: ClassUnicodeKind::OneLetter('a'),",
                  "        })),",
                  "    ]);",
                  "    ",
                  "    translator.push(HirFrame::Expr(Hir::group(Group {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "    })));",
                  "    translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {",
                  "        span: Span { start: 1, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    }))));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    let exprs = if let HirKind::Alternation(exprs) = expr.kind() {",
                  "    exprs",
                  "    } else {",
                  "    panic!(\"Expected expression kind to be Alternation\");",
                  "    };",
                  "    assert!(matches!(exprs[0].kind(), HirKind::Group(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Alternation(vec![",
                  "        Ast::Group(Group {",
                  "            span: Span { start: 0, end: 1 },",
                  "            kind: GroupKind::NonCapturing,",
                  "            ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "        }),",
                  "        Ast::Class(ast::Class::Unicode(ClassUnicode {",
                  "            span: Span { start: 1, end: 2 },",
                  "            negated: false,",
                  "            kind: ClassUnicodeKind::OneLetter('a'),",
                  "        })),",
                  "    ]);",
                  "    ",
                  "    translator.push(HirFrame::Expr(Hir::group(Group {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),",
                  "    })));",
                  "    translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {",
                  "        span: Span { start: 1, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    }))));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let expr = if let Some(HirFrame::Expr(expr)) = stack.pop() {",
                  "    expr",
                  "    } else {",
                  "    panic!(\"Expected to pop an expression from stack\");",
                  "    };",
                  "    let exprs = if let HirKind::Alternation(exprs) = expr.kind() {",
                  "    exprs",
                  "    } else {",
                  "    panic!(\"Expected expression kind to be Alternation\");",
                  "    };",
                  "    assert!(matches!(exprs[1].kind(), HirKind::Class(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:20\n     |\n2546 |         Ast::Group(Group {\n     |                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |             kind: GroupKind::NonCapturing,\n     |                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:40\n     |\n2551 |         Ast::Class(ast::Class::Unicode(ClassUnicode {\n     |                                        ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2554:19\n     |\n2554 |             kind: ClassUnicodeKind::OneLetter('a'),\n     |                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:47\n     |\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |                                               ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2563:47\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                               ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                                              ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:41\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:60\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:41\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |       let ast = Ast::Alternation(vec![\n     |  _______________----------------_^\n     | |               |\n     | |               arguments to this enum variant are incorrect\n2546 | |         Ast::Group(Group {\n2547 | |             span: Span { start: 0, end: 1 },\n2548 | |             kind: GroupKind::NonCapturing,\n...    |\n2555 | |         })),\n2556 | |     ]);\n     | |_____^ expected `Alternation`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:37\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:56\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:37\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:20\n     |\n2546 |         Ast::Group(Group {\n     |                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |             kind: GroupKind::NonCapturing,\n     |                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:40\n     |\n2551 |         Ast::Class(ast::Class::Unicode(ClassUnicode {\n     |                                        ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2554:19\n     |\n2554 |             kind: ClassUnicodeKind::OneLetter('a'),\n     |                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:47\n     |\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |                                               ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2563:47\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                               ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                                              ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:35\n     |\n2576 |     assert!(matches!(expr.kind(), HirKind::Alternation(_)));\n     |                                   ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:41\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:60\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:41\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |       let ast = Ast::Alternation(vec![\n     |  _______________----------------_^\n     | |               |\n     | |               arguments to this enum variant are incorrect\n2546 | |         Ast::Group(Group {\n2547 | |             span: Span { start: 0, end: 1 },\n2548 | |             kind: GroupKind::NonCapturing,\n...    |\n2555 | |         })),\n2556 | |     ]);\n     | |_____^ expected `Alternation`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:37\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:56\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:37\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:20\n     |\n2546 |         Ast::Group(Group {\n     |                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |             kind: GroupKind::NonCapturing,\n     |                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:40\n     |\n2551 |         Ast::Class(ast::Class::Unicode(ClassUnicode {\n     |                                        ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2554:19\n     |\n2554 |             kind: ClassUnicodeKind::OneLetter('a'),\n     |                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:47\n     |\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |                                               ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2563:47\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                               ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                                              ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:24\n     |\n2576 |     let exprs = if let HirKind::Alternation(exprs) = expr.kind() {\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:41\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:60\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:41\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |       let ast = Ast::Alternation(vec![\n     |  _______________----------------_^\n     | |               |\n     | |               arguments to this enum variant are incorrect\n2546 | |         Ast::Group(Group {\n2547 | |             span: Span { start: 0, end: 1 },\n2548 | |             kind: GroupKind::NonCapturing,\n...    |\n2555 | |         })),\n2556 | |     ]);\n     | |_____^ expected `Alternation`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:37\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:56\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:37\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:20\n     |\n2546 |         Ast::Group(Group {\n     |                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |             kind: GroupKind::NonCapturing,\n     |                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:40\n     |\n2551 |         Ast::Class(ast::Class::Unicode(ClassUnicode {\n     |                                        ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2554:19\n     |\n2554 |             kind: ClassUnicodeKind::OneLetter('a'),\n     |                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:47\n     |\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |                                               ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2563:47\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                               ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                                              ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:24\n     |\n2576 |     let exprs = if let HirKind::Alternation(exprs) = expr.kind() {\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2581:39\n     |\n2581 |     assert!(matches!(exprs[0].kind(), HirKind::Group(_)));\n     |                                       ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:41\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:60\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:41\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |       let ast = Ast::Alternation(vec![\n     |  _______________----------------_^\n     | |               |\n     | |               arguments to this enum variant are incorrect\n2546 | |         Ast::Group(Group {\n2547 | |             span: Span { start: 0, end: 1 },\n2548 | |             kind: GroupKind::NonCapturing,\n...    |\n2555 | |         })),\n2556 | |     ]);\n     | |_____^ expected `Alternation`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:37\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:56\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:37\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:20\n     |\n2546 |         Ast::Group(Group {\n     |                    ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |             kind: GroupKind::NonCapturing,\n     |                   ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:40\n     |\n2551 |         Ast::Class(ast::Class::Unicode(ClassUnicode {\n     |                                        ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2554:19\n     |\n2554 |             kind: ClassUnicodeKind::OneLetter('a'),\n     |                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:47\n     |\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |                                               ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2560:15\n     |\n2560 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2563:47\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                               ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:62\n     |\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |                                                              ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:24\n     |\n2576 |     let exprs = if let HirKind::Alternation(exprs) = expr.kind() {\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2581:39\n     |\n2581 |     assert!(matches!(exprs[1].kind(), HirKind::Class(_)));\n     |                                       ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:41\n     |\n2547 |             span: Span { start: 0, end: 1 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:52\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:60\n     |\n2549 |             ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:41\n     |\n2552 |             span: Span { start: 1, end: 2 },\n     |                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:32\n     |\n2545 |       let ast = Ast::Alternation(vec![\n     |  _______________----------------_^\n     | |               |\n     | |               arguments to this enum variant are incorrect\n2546 | |         Ast::Group(Group {\n2547 | |             span: Span { start: 0, end: 1 },\n2548 | |             kind: GroupKind::NonCapturing,\n...    |\n2555 | |         })),\n2556 | |     ]);\n     | |_____^ expected `Alternation`, found `Vec<Ast>`\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::Expr(Hir::group(Group {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:37\n     |\n2559 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:56\n     |\n2561 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 1 })),\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2563 |     translator.push(HirFrame::Expr(Hir::class(Class::Unicode(ClassUnicode {\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:37\n     |\n2564 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(_) is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is false\n",
        "// constraint: let Some(HirFrame::Expr(expr)) = self.pop() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Alternation(vec![Ast::Literal(Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Char('a'), c: 'a' }), Ast::Literal(Literal { span: Span { start: 1, end: 2 }, kind: LiteralKind::Char('b'), c: 'b' })]) with multiple frames on the stack including successful expressions and one empty expression.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = ast::Ast::Literal(ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Char('a'),",
                "        c: 'a',",
                "    });",
                "    let literal_b = ast::Ast::Literal(ast::Literal {",
                "        span: Span { start: 1, end: 2 },",
                "        kind: ast::LiteralKind::Char('b'),",
                "        c: 'b',",
                "    });",
                "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![",
                "            HirFrame::Expr(Hir::literal(ast::Literal {",
                "                span: Span { start: 2, end: 3 },",
                "                kind: ast::LiteralKind::Char('c'),",
                "                c: 'c',",
                "            })),",
                "            HirFrame::Expr(Hir::empty()),",
                "        ]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                "    visitor.visit_post(&alternation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 3);"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert!(matches!(stack[0], HirFrame::Expr(_)));"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert!(matches!(stack[1], HirFrame::Expr(_)));"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert!(matches!(stack[2], HirFrame::Expr(_)));"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert!(expr1.kind().is_empty());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert!(!expr2.kind().is_empty());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert!(!expr3.kind().is_empty());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert_eq!(expr2.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' }));"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert_eq!(expr3.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b' }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert!(matches!(stack[0], HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert!(matches!(stack[1], HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert!(matches!(stack[2], HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert!(expr1.kind().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert!(!expr2.kind().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert!(!expr3.kind().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert_eq!(expr2.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' }));",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::empty()),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"abcd\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let expr1 = if let HirFrame::Expr(expr) = &stack[0] { expr } else { panic!() };",
                  "    let expr2 = if let HirFrame::Expr(expr) = &stack[1] { expr } else { panic!() };",
                  "    let expr3 = if let HirFrame::Expr(expr) = &stack[2] { expr } else { panic!() };",
                  "    assert_eq!(expr3.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b' }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2571:31\n     |\n2571 |     assert_eq!(expr2.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' ...\n     |                               ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:83\n     |\n2571 |     assert_eq!(expr2.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' ...\n     |                                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:91\n     |\n2571 |     assert_eq!(expr2.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' ...\n     |                                                                                           ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:120\n     |\n2571 | ... 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2571:31\n     |\n2571 |     assert_eq!(expr3.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b' ...\n     |                               ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a, literal_b]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:83\n     |\n2571 |     assert_eq!(expr3.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b' ...\n     |                                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:91\n     |\n2571 |     assert_eq!(expr3.kind(), &HirKind::Literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b' ...\n     |                                                                                           ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:120\n     |\n2571 | ... 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = ast::Ast::Literal(ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Char('a'),",
                "        c: 'a',",
                "    });",
                "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::Expr(Hir::empty())]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                "    visitor.visit_post(&alternation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    assert!(matches!(expr.kind(), HirKind::Alternation(_)));"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    assert!(visitor.pop().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::Expr(Hir::empty())]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::Expr(Hir::empty())]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    assert!(matches!(expr.kind(), HirKind::Alternation(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::Expr(Hir::empty())]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:45\n     |\n2545 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2561:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2558 |     HirFrame::Expr(expr) => {\n     |                             - this delimiter might not be properly closed...\n2559 |     assert!(matches!(expr.kind(), HirKind::Alternation(_)));\n2560 | }\n     | - ...as it matches this but it has different indentation\n2561 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:45\n     |\n2545 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let literal_a = ast::Ast::Literal(ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Char('a'),",
                "        c: 'a',",
                "    });",
                "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                "    visitor.visit_post(&alternation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    assert!(visitor.trans().stack.borrow().is_empty() == false);"
                ],
                [
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_alternation() == true);"
                ],
                [
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().stack.borrow().is_empty() == false);"
                ],
                [
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_empty() == true);"
                ],
                [
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.finish().is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    assert!(visitor.trans().stack.borrow().is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_alternation() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().stack.borrow().is_empty() == false);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_empty() == true);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a]);",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.finish().is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:29\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:37\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:33\n     |\n2543 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:45\n     |\n2546 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:74\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:82\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:111\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:45\n     |\n2557 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:29\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:37\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:33\n     |\n2543 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:45\n     |\n2546 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:74\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:82\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:111\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:45\n     |\n2557 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0599]: no method named `is_alternation` found for reference `&HirKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:25\n     |\n2559 |     assert!(expr.kind().is_alternation() == true);\n     |                         ^^^^^^^^^^^^^^ method not found in `&HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:29\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:37\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:33\n     |\n2543 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:45\n     |\n2546 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:74\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:82\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:111\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:45\n     |\n2557 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:29\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:37\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:33\n     |\n2543 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:45\n     |\n2546 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:74\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:82\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:111\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:45\n     |\n2557 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:29\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:37\n     |\n2542 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2543:33\n     |\n2543 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:45\n     |\n2546 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:74\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:82\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                  ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:111\n     |\n2556 |     let literal_a = ast::Ast::Literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a' });\n     |                                                                                                               ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:45\n     |\n2557 |     let alternation = ast::Ast::Alternation(vec![literal_a]);\n     |                       --------------------- ^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let literal_a = ast::Ast::Literal(ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Char('a'),",
                "        c: 'a',",
                "    });",
                "    let literal_b = ast::Ast::Literal(ast::Literal {",
                "        span: Span { start: 1, end: 2 },",
                "        kind: ast::LiteralKind::Char('b'),",
                "        c: 'b',",
                "    });",
                "    let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![",
                "            HirFrame::Expr(Hir::literal(ast::Literal {",
                "                span: Span { start: 2, end: 3 },",
                "                kind: ast::LiteralKind::Char('c'),",
                "                c: 'c',",
                "            })),",
                "            HirFrame::Expr(Hir::literal(ast::Literal {",
                "                span: Span { start: 3, end: 4 },",
                "                kind: ast::LiteralKind::Char('d'),",
                "                c: 'd',",
                "            })),",
                "        ]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"ab\");",
                "    visitor.visit_post(&alternation).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    assert!(exprs.len() == 2);"
                ],
                [
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];",
                  "    assert_eq!(exprs, expected_exprs);"
                ],
                [
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];",
                  "    assert!(matches!(self.pop(), None));"
                ],
                [
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];",
                  "    assert!(matches!(self.pop(), Some(HirFrame::Expr(expr))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 3, end: 4 },",
                  "                kind: ast::LiteralKind::Char('d'),",
                  "                c: 'd',",
                  "            })),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"ab\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    assert!(exprs.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 3, end: 4 },",
                  "                kind: ast::LiteralKind::Char('d'),",
                  "                c: 'd',",
                  "            })),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"ab\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];",
                  "    assert_eq!(exprs, expected_exprs);",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 3, end: 4 },",
                  "                kind: ast::LiteralKind::Char('d'),",
                  "                c: 'd',",
                  "            })),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"ab\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];",
                  "    assert!(matches!(self.pop(), None));",
                  "}"
                ],
                [
                  "{",
                  "    let literal_a = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Char('a'),",
                  "        c: 'a',",
                  "    });",
                  "    let literal_b = ast::Ast::Literal(ast::Literal {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::LiteralKind::Char('b'),",
                  "        c: 'b',",
                  "    });",
                  "    let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 2, end: 3 },",
                  "                kind: ast::LiteralKind::Char('c'),",
                  "                c: 'c',",
                  "            })),",
                  "            HirFrame::Expr(Hir::literal(ast::Literal {",
                  "                span: Span { start: 3, end: 4 },",
                  "                kind: ast::LiteralKind::Char('d'),",
                  "                c: 'd',",
                  "            })),",
                  "        ]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"ab\");",
                  "    visitor.visit_post(&alternation).unwrap();",
                  "    let mut exprs = vec![];",
                  "    while let Some(HirFrame::Expr(expr)) = self.pop() {}",
                  "    let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];",
                  "    assert!(matches!(self.pop(), Some(HirFrame::Expr(expr))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2572:44\n     |\n2538 | fn test_visit_post_76()\n     |    ------------------ this function can't have a `self` parameter\n...\n2572 |     while let Some(HirFrame::Expr(expr)) = self.pop() {}\n     |                                            ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:37\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:41\n     |\n2561 |                 kind: ast::LiteralKind::Char('d'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:41\n     |\n2559 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2560 | |                 span: Span { start: 3, end: 4 },\n2561 | |                 kind: ast::LiteralKind::Char('d'),\n2562 | |                 c: 'd',\n2563 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0424, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2572:44\n     |\n2538 | fn test_visit_post_77()\n     |    ------------------ this function can't have a `self` parameter\n...\n2572 |     while let Some(HirFrame::Expr(expr)) = self.pop() {}\n     |                                            ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:37\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:41\n     |\n2561 |                 kind: ast::LiteralKind::Char('d'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:41\n     |\n2559 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2560 | |                 span: Span { start: 3, end: 4 },\n2561 | |                 kind: ast::LiteralKind::Char('d'),\n2562 | |                 c: 'd',\n2563 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:79\n     |\n2573 |     let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }),...\n     |                                                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:87\n     |\n2573 |     let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }),...\n     |                                                                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:116\n     |\n2573 | ... 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::L...\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 | ...prs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(as...\n     |               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |               |\n     |               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:187\n     |\n2573 | ... Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:195\n     |\n2573 | ...teral(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:224\n     |\n2573 | ... 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:152\n     |\n2573 | ...: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |               |\n     |               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0424, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2572:44\n     |\n2538 | fn test_visit_post_78()\n     |    ------------------ this function can't have a `self` parameter\n...\n2572 |     while let Some(HirFrame::Expr(expr)) = self.pop() {}\n     |                                            ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2574:22\n     |\n2538 | fn test_visit_post_78()\n     |    ------------------ this function can't have a `self` parameter\n...\n2574 |     assert!(matches!(self.pop(), None));\n     |                      ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:37\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:41\n     |\n2561 |                 kind: ast::LiteralKind::Char('d'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:41\n     |\n2559 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2560 | |                 span: Span { start: 3, end: 4 },\n2561 | |                 kind: ast::LiteralKind::Char('d'),\n2562 | |                 c: 'd',\n2563 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:79\n     |\n2573 |     let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }),...\n     |                                                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:87\n     |\n2573 |     let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }),...\n     |                                                                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:116\n     |\n2573 | ... 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::L...\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 | ...prs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(as...\n     |               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |               |\n     |               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:187\n     |\n2573 | ... Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:195\n     |\n2573 | ...teral(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:224\n     |\n2573 | ... 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:152\n     |\n2573 | ...: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |               |\n     |               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0424, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2572:44\n     |\n2538 | fn test_visit_post_79()\n     |    ------------------ this function can't have a `self` parameter\n...\n2572 |     while let Some(HirFrame::Expr(expr)) = self.pop() {}\n     |                                            ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2574:22\n     |\n2538 | fn test_visit_post_79()\n     |    ------------------ this function can't have a `self` parameter\n...\n2574 |     assert!(matches!(self.pop(), Some(HirFrame::Expr(expr))));\n     |                      ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:29\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:37\n     |\n2541 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2542:33\n     |\n2542 |         kind: ast::LiteralKind::Char('a'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Char('b'),\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:45\n     |\n2550 |     let alternation = ast::Ast::Alternation(vec![literal_a.clone(), literal_b.clone()]);\n     |                       --------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Alternation`\n                found struct `Vec<Ast>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:497:5\n     |\n497  |     Alternation(Alternation),\n     |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:37\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:45\n     |\n2555 |                 span: Span { start: 2, end: 3 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:41\n     |\n2556 |                 kind: ast::LiteralKind::Char('c'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:41\n     |\n2554 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2555 | |                 span: Span { start: 2, end: 3 },\n2556 | |                 kind: ast::LiteralKind::Char('c'),\n2557 | |                 c: 'c',\n2558 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:37\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |                 span: Span { start: 3, end: 4 },\n     |                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:41\n     |\n2561 |                 kind: ast::LiteralKind::Char('d'),\n     |                                         ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:41\n     |\n2559 |               HirFrame::Expr(Hir::literal(ast::Literal {\n     |  ____________________________------------_^\n     | |                            |\n     | |                            arguments to this function are incorrect\n2560 | |                 span: Span { start: 3, end: 4 },\n2561 | |                 kind: ast::LiteralKind::Char('d'),\n2562 | |                 c: 'd',\n2563 | |             })),\n     | |_____________^ expected `hir::Literal`, found `ast::Literal`\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:79\n     |\n2573 |     let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }),...\n     |                                                                               ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:87\n     |\n2573 |     let expected_exprs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }),...\n     |                                                                                       ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:116\n     |\n2573 | ... 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::L...\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 | ...prs = vec![Hir::literal(ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Char('a'), c: 'a', }), Hir::literal(as...\n     |               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |               |\n     |               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:187\n     |\n2573 | ... Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:195\n     |\n2573 | ...teral(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:224\n     |\n2573 | ... 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:152\n     |\n2573 | ...: 'a', }), Hir::literal(ast::Literal { span: Span { start: 1, end: 2 }, kind: ast::LiteralKind::Char('b'), c: 'b', })];\n     |               ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |               |\n     |               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0424, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: let Some(flags) = self.pop().unwrap().unwrap_group() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Group(ref x) with non-empty child expressions; flags set in Translator; ensure pop() returns valid HirFrame with valid expressions.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: 0, end: 5 };",
                "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                "    let group = ast::Group {",
                "        span,",
                "        kind: ast::GroupKind::NonCapturing,",
                "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                "    };",
                "",
                "    translator.flags.set(Flags {",
                "        case_insensitive: Some(true),",
                "        multi_line: Some(false),",
                "        dot_matches_new_line: Some(false),",
                "        swap_greed: Some(false),",
                "        unicode: Some(true),",
                "    });",
                "",
                "    let group_ast = ast::Ast::Group(group);",
                "    translator.visit_post(&group_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "    span,",
                  "    kind: ast::GroupKind::NonCapturing,",
                  "    ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    translator.flags.set(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(true),",
                  "    });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    assert!(translator.stack.borrow().len() == 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "    span,",
                  "    kind: ast::GroupKind::NonCapturing,",
                  "    ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    translator.flags.set(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(true),",
                  "    });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::Expr(_))));"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "    span,",
                  "    kind: ast::GroupKind::NonCapturing,",
                  "    ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    translator.flags.set(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(true),",
                  "    });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    assert!(matches!(translator.pop(), Some(HirFrame::Expr(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "    span,",
                  "    kind: ast::GroupKind::NonCapturing,",
                  "    ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    translator.flags.set(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(true),",
                  "    });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    assert!(translator.stack.borrow().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "    span,",
                  "    kind: ast::GroupKind::NonCapturing,",
                  "    ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    translator.flags.set(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(true),",
                  "    });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::Expr(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let group = ast::Group {",
                  "    span,",
                  "    kind: ast::GroupKind::NonCapturing,",
                  "    ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    translator.flags.set(Flags {",
                  "    case_insensitive: Some(true),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(true),",
                  "    });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    assert!(matches!(translator.pop(), Some(HirFrame::Expr(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2550 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:30\n     |\n2569 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:64\n     |\n2570 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:11\n     |\n2573 |     kind: ast::GroupKind::NonCapturing,\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2573 |     kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                       ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2584:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2584 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2550 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:30\n     |\n2569 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:64\n     |\n2570 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:11\n     |\n2573 |     kind: ast::GroupKind::NonCapturing,\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2573 |     kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                       ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2584:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2584 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:15\n     |\n2550 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2550 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:30\n     |\n2569 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:38\n     |\n2569 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:64\n     |\n2570 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:11\n     |\n2573 |     kind: ast::GroupKind::NonCapturing,\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2573 |     kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                       ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2584:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2584 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2585 |     assert!(matches!(translator.pop(), Some(HirFrame::Expr(_))));\n     |                                 ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: 0, end: 5 };",
                "    let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };",
                "    let group = ast::Group {",
                "        span,",
                "        kind: ast::GroupKind::CaptureIndex(1),",
                "        ast: Box::new(ast::Ast::Flags(flag_set)),",
                "    };",
                "",
                "    translator.flags.set(Flags {",
                "        case_insensitive: Some(true),",
                "        multi_line: Some(true),",
                "        dot_matches_new_line: Some(false),",
                "        swap_greed: Some(false),",
                "        unicode: Some(true),",
                "    });",
                "",
                "    let group_ast = ast::Ast::Group(group);",
                "    translator.visit_post(&group_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    assert!(matches!(hir.kind(), HirKind::Group(_)));"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_group().is_some());"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    let frame = translator.pop().unwrap();",
                  "    assert_eq!(translator.flags().case_insensitive, Some(true));"
                ],
                [
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    let frame = translator.pop().unwrap();",
                  "    assert_eq!(translator.flags().multi_line, Some(true));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::CaptureIndex(1),",
                  "        ast: Box::new(ast::Ast::Flags(flag_set)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::CaptureIndex(1),",
                  "        ast: Box::new(ast::Ast::Flags(flag_set)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    assert!(matches!(hir.kind(), HirKind::Group(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::CaptureIndex(1),",
                  "        ast: Box::new(ast::Ast::Flags(flag_set)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_group().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::CaptureIndex(1),",
                  "        ast: Box::new(ast::Ast::Flags(flag_set)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    let frame = translator.pop().unwrap();",
                  "    assert_eq!(translator.flags().case_insensitive, Some(true));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::CaptureIndex(1),",
                  "        ast: Box::new(ast::Ast::Flags(flag_set)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(true),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut stack = translator.stack.borrow_mut();",
                  "    let frame = stack.pop().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    },",
                  "    _ => panic!(\"Expected HirFrame::Expr\"),",
                  "    }",
                  "    let frame = translator.pop().unwrap();",
                  "    assert_eq!(translator.flags().multi_line, Some(true));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2547:39\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                       ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:75\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:39\n     |\n2551 |         ast: Box::new(ast::Ast::Flags(flag_set)),\n     |                       --------------- ^^^^^^^^ expected `SetFlags`, found `Flags`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2570:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2567 |     HirFrame::Expr(hir) => {\n     |                            - this delimiter might not be properly closed...\n2568 |     assert!(matches!(hir.kind(), HirKind::Group(_)));\n2569 | }\n     | - ...as it matches this but it has different indentation\n2570 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2547:39\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                       ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:75\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:39\n     |\n2551 |         ast: Box::new(ast::Ast::Flags(flag_set)),\n     |                       --------------- ^^^^^^^^ expected `SetFlags`, found `Flags`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2571 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2547:39\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                       ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:75\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:39\n     |\n2551 |         ast: Box::new(ast::Ast::Flags(flag_set)),\n     |                       --------------- ^^^^^^^^ expected `SetFlags`, found `Flags`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2571 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nerror[E0599]: no method named `flags` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `flags` not found for this struct\n...\n2572 |     assert_eq!(translator.flags().case_insensitive, Some(true));\n     |                           ^^^^^-- help: remove the arguments\n     |                           |\n     |                           field, not a method\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2547:39\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                       ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:75\n     |\n2547 |     let flag_set = ast::Flags { span, flags: Flags::from_ast(&ast::Flags::default()) };\n     |                                                                           ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:39\n     |\n2551 |         ast: Box::new(ast::Ast::Flags(flag_set)),\n     |                       --------------- ^^^^^^^^ expected `SetFlags`, found `Flags`\n     |                       |\n     |                       arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2571 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nerror[E0599]: no method named `flags` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `flags` not found for this struct\n...\n2572 |     assert_eq!(translator.flags().multi_line, Some(true));\n     |                           ^^^^^-- help: remove the arguments\n     |                           |\n     |                           field, not a method\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: 0, end: 5 };",
                "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                "    let repetition = ast::Repetition {",
                "        span,",
                "        op: ast::RepetitionOp::ZeroOrMore,",
                "        greedy: true,",
                "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                "    };",
                "    let group = ast::Group {",
                "        span,",
                "        kind: ast::GroupKind::NonCapturing,",
                "        ast: Box::new(ast::Ast::Repetition(repetition)),",
                "    };",
                "",
                "    translator.flags.set(Flags {",
                "        case_insensitive: Some(false),",
                "        multi_line: Some(true),",
                "        dot_matches_new_line: Some(false),",
                "        swap_greed: Some(true),",
                "        unicode: Some(true),",
                "    });",
                "",
                "    let group_ast = ast::Ast::Group(group);",
                "    translator.visit_post(&group_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(translator.visit_post(&group_ast).is_ok());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::Expr(_))));"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(translator.stack.borrow().len() == 1);"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(matches!(translator.pop(), Some(HirFrame::Expr(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition {",
                  "        span,",
                  "        op: ast::RepetitionOp::ZeroOrMore,",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Repetition(repetition)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(true),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(translator.visit_post(&group_ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition {",
                  "        span,",
                  "        op: ast::RepetitionOp::ZeroOrMore,",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Repetition(repetition)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(true),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition {",
                  "        span,",
                  "        op: ast::RepetitionOp::ZeroOrMore,",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Repetition(repetition)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(true),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::Expr(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition {",
                  "        span,",
                  "        op: ast::RepetitionOp::ZeroOrMore,",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Repetition(repetition)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(true),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(translator.stack.borrow().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition {",
                  "        span,",
                  "        op: ast::RepetitionOp::ZeroOrMore,",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Literal(literal.clone())),",
                  "    };",
                  "    let group = ast::Group {",
                  "        span,",
                  "        kind: ast::GroupKind::NonCapturing,",
                  "        ast: Box::new(ast::Ast::Repetition(repetition)),",
                  "    };",
                  "",
                  "    translator.flags.set(Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(true),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(true),",
                  "        unicode: Some(true),",
                  "    });",
                  "",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    translator.visit_post(&group_ast).unwrap();",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };",
                  "    let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clone())) };",
                  "    let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };",
                  "    translator.flags.set(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: Some(true), unicode: Some(true) });",
                  "    let group_ast = ast::Ast::Group(group);",
                  "    assert!(matches!(translator.pop(), Some(HirFrame::Expr(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:32\n     |\n2550 |         op: ast::RepetitionOp::ZeroOrMore,\n     |                                ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2556 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:38\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:64\n     |\n2572 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:69\n     |\n2573 |     let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clo...\n     |                                                                     ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:42\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing(/* ast::Flags */), ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                                                      ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2577:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2577 |     assert!(translator.visit_post(&group_ast).is_ok());\n     |                        ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:32\n     |\n2550 |         op: ast::RepetitionOp::ZeroOrMore,\n     |                                ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2556 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:38\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:64\n     |\n2572 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:69\n     |\n2573 |     let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clo...\n     |                                                                     ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:42\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing(/* ast::Flags */), ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                                                      ++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:32\n     |\n2550 |         op: ast::RepetitionOp::ZeroOrMore,\n     |                                ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2556 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:38\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:64\n     |\n2572 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:69\n     |\n2573 |     let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clo...\n     |                                                                     ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:42\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing(/* ast::Flags */), ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                                                      ++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:32\n     |\n2550 |         op: ast::RepetitionOp::ZeroOrMore,\n     |                                ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2556 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:38\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:64\n     |\n2572 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:69\n     |\n2573 |     let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clo...\n     |                                                                     ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:42\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing(/* ast::Flags */), ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                                                      ++++++++++++++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:32\n     |\n2550 |         op: ast::RepetitionOp::ZeroOrMore,\n     |                                ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ast::GroupKind::NonCapturing,\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2556 |         kind: ast::GroupKind::NonCapturing(/* ast::Flags */),\n     |                                           ++++++++++++++++++\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2569 |     translator.visit_post(&group_ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:38\n     |\n2571 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:64\n     |\n2572 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char('a'), c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0599]: no associated item named `ZeroOrMore` found for struct `RepetitionOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:69\n     |\n2573 |     let repetition = ast::Repetition { span, op: ast::RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast::Ast::Literal(literal.clo...\n     |                                                                     ^^^^^^^^^^ associated item not found in `RepetitionOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1140:1\n     |\n1140 | pub struct RepetitionOp {\n     | ----------------------- associated item `ZeroOrMore` not found for this struct\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:42\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `GroupKind`, found enum constructor\n     |\n    ::: regex-syntax/src/ast/mod.rs:1239:5\n     |\n1239 |     NonCapturing(Flags),\n     |     ------------ `NonCapturing` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `ast::GroupKind`\n             found enum constructor `fn(ast::Flags) -> ast::GroupKind {ast::GroupKind::NonCapturing}`\nhelp: use parentheses to construct this tuple variant\n     |\n2574 |     let group = ast::Group { span, kind: ast::GroupKind::NonCapturing(/* ast::Flags */), ast: Box::new(ast::Ast::Repetition(repetition)) };\n     |                                                                      ++++++++++++++++++\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2577 |     assert!(matches!(translator.pop(), Some(HirFrame::Expr(_))));\n     |                                 ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n",
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= x <= N, where N is a defined positive integer indicating repetition limits.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestTranslator {",
                "        trans: Translator,",
                "    }",
                "",
                "    impl TestTranslator {",
                "        fn new() -> Self {",
                "            TestTranslator {",
                "                trans: Translator {",
                "                    stack: RefCell::new(vec![]),",
                "                    flags: Cell::new(Flags::default()),",
                "                    allow_invalid_utf8: false,",
                "                },",
                "            }",
                "        }",
                "        ",
                "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                "            // Here we call the visit_post function",
                "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                "            visitor.visit_post(&ast)",
                "        }",
                "    }",
                "",
                "    let mut translator = TestTranslator::new();",
                "    ",
                "    let group_span = Span { start: Position(0), end: Position(1) };",
                "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                "    ",
                "    let group = Group {",
                "        span: group_span,",
                "        kind: GroupKind::NonCapturing,",
                "        ast: Box::new(Ast::Repetition(repetition_op)),",
                "    };",
                "",
                "    // Valid repetition test",
                "    let ast = Ast::Group(group);",
                "    let _ = translator.visit_post(ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::Expr(_)));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    let expr = frame.unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Repetition(_));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    let expr = frame.unwrap_expr();",
                  "    assert!(expr.is_any_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    let expr = frame.unwrap_expr();",
                  "    assert!(expr.is_any_anchored_end());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    let expr = frame.unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Repetition(_));",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    let expr = frame.unwrap_expr();",
                  "    assert!(expr.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(3);",
                  "    let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    let group = Group {",
                  "    span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let frame = translator.trans.stack.borrow_mut().pop().unwrap();",
                  "    let expr = frame.unwrap_expr();",
                  "    assert!(expr.is_any_anchored_end());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:30\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:48\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:53\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                     ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:79\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                               ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                               +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:30\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:48\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:53\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                     ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:79\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                               ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                               +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2589:30\n     |\n2589 |     assert_eq!(expr.kind(), &HirKind::Repetition(_));\n     |                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> regex-syntax/src/hir/translate.rs:2589:50\n     |\n2589 |     assert_eq!(expr.kind(), &HirKind::Repetition(_));\n     |                                                  ^ `_` not allowed here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:30\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:48\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:53\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                     ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:79\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                               ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                               +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:30\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:48\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:53\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                     ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:79\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                               ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                               +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:30\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:48\n     |\n2577 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:53\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                     ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:79\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                               ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                               +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestTranslator {",
                "        trans: Translator,",
                "    }",
                "",
                "    impl TestTranslator {",
                "        fn new() -> Self {",
                "            TestTranslator {",
                "                trans: Translator {",
                "                    stack: RefCell::new(vec![]),",
                "                    flags: Cell::new(Flags::default()),",
                "                    allow_invalid_utf8: false,",
                "                },",
                "            }",
                "        }",
                "        ",
                "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                "            // Here we call the visit_post function",
                "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                "            visitor.visit_post(&ast)",
                "        }",
                "    }",
                "",
                "    let mut translator = TestTranslator::new();",
                "    ",
                "    let group_span = Span { start: Position(0), end: Position(1) };",
                "    let repetition_range = ast::RepetitionRange::Exactly(0);",
                "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                "    ",
                "    let group = Group {",
                "        span: group_span,",
                "        kind: GroupKind::NonCapturing,",
                "        ast: Box::new(Ast::Repetition(repetition_op)),",
                "    };",
                "",
                "    // Valid repetition test with zero",
                "    let ast = Ast::Group(group);",
                "    let _ = translator.visit_post(ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = translator.trans.stack.borrow_mut();",
                  "    assert!(stack.len() == 1);"
                ],
                [
                  "    let mut stack = translator.trans.stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    assert_eq!(hir.kind(), &HirKind::Group(Group {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(0);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test with zero",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let mut stack = translator.trans.stack.borrow_mut();",
                  "    assert!(stack.len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::Exactly(0);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition test with zero",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let mut stack = translator.trans.stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    assert_eq!(hir.kind(), &HirKind::Group(Group {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: true };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: true };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n    --> regex-syntax/src/hir/translate.rs:2581:43\n     |\n2539 | {\n     | - closing delimiter possibly meant for this\n...\n2581 |     assert_eq!(hir.kind(), &HirKind::Group(Group {\n     |                                           ^ unclosed delimiter\n2582 | }\n2583 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2583:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2579 |     match frame {\n     |                 - unclosed delimiter\n2580 |     HirFrame::Expr(hir) => {\n2581 |     assert_eq!(hir.kind(), &HirKind::Group(Group {\n     |                                                  - this delimiter might not be properly closed...\n2582 | }\n     | - ...as it matches this but it has different indentation\n2583 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestTranslator {",
                "        trans: Translator,",
                "    }",
                "",
                "    impl TestTranslator {",
                "        fn new() -> Self {",
                "            TestTranslator {",
                "                trans: Translator {",
                "                    stack: RefCell::new(vec![]),",
                "                    flags: Cell::new(Flags::default()),",
                "                    allow_invalid_utf8: false,",
                "                },",
                "            }",
                "        }",
                "        ",
                "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                "            // Here we call the visit_post function",
                "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                "            visitor.visit_post(&ast)",
                "        }",
                "    }",
                "",
                "    let mut translator = TestTranslator::new();",
                "    ",
                "    let group_span = Span { start: Position(0), end: Position(1) };",
                "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                "    ",
                "    let group = Group {",
                "        span: group_span,",
                "        kind: GroupKind::NonCapturing,",
                "        ast: Box::new(Ast::Repetition(repetition_op)),",
                "    };",
                "",
                "    // Valid repetition with large range",
                "    let ast = Ast::Group(group);",
                "    let _ = translator.visit_post(ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_some());"
                ],
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.stack.borrow_mut().is_empty());"
                ],
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().multi_line.is_none());"
                ],
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().unicode.is_some());"
                ],
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().case_insensitive.is_none());"
                ],
                [
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().dot_matches_new_line.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(expr.kind().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.stack.borrow_mut().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().multi_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().unicode.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().case_insensitive.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestTranslator {",
                  "        trans: Translator,",
                  "    }",
                  "",
                  "    impl TestTranslator {",
                  "        fn new() -> Self {",
                  "            TestTranslator {",
                  "                trans: Translator {",
                  "                    stack: RefCell::new(vec![]),",
                  "                    flags: Cell::new(Flags::default()),",
                  "                    allow_invalid_utf8: false,",
                  "                },",
                  "            }",
                  "        }",
                  "        ",
                  "        fn visit_post(&mut self, ast: Ast) -> Result<()> {",
                  "            // Here we call the visit_post function",
                  "            let mut visitor = TranslatorI::new(&self.trans, \"\");",
                  "            visitor.visit_post(&ast)",
                  "        }",
                  "    }",
                  "",
                  "    let mut translator = TestTranslator::new();",
                  "    ",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    ",
                  "    let group = Group {",
                  "        span: group_span,",
                  "        kind: GroupKind::NonCapturing,",
                  "        ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "",
                  "    // Valid repetition with large range",
                  "    let ast = Ast::Group(group);",
                  "    let _ = translator.visit_post(ast);",
                  "    let group_span = Span { start: Position(0), end: Position(1) };",
                  "    let repetition_range = ast::RepetitionRange::AtLeast(5);",
                  "    let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };",
                  "    let group = Group {",
                  "    span: group_span,",
                  "    kind: GroupKind::NonCapturing,",
                  "    ast: Box::new(Ast::Repetition(repetition_op)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = translator.visit_post(ast);",
                  "    let expr = translator.trans.stack.borrow_mut().pop().unwrap().unwrap_expr();",
                  "    assert!(translator.trans.flags.get().dot_matches_new_line.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0599]: no method named `is_some` found for reference `&HirKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     assert!(expr.kind().is_some());\n     |                         ^^^^^^^ method not found in `&HirKind`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:17\n     |\n2568 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2570:15\n     |\n2570 |         kind: GroupKind::NonCapturing,\n     |               ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:17\n     |\n2580 |     let group = Group {\n     |                 ^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Group;\n     |\n2535 +    use hir::Group;\n     |\n2535 +    use hir::HirKind::Group;\n     |\n2535 +    use hir::translate::Ast::Group;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: GroupKind::NonCapturing,\n     |           ^^^^^^^^^ use of undeclared type `GroupKind`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::GroupKind;\n     |\n2535 +    use hir::GroupKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:54\n     |\n2564 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:36\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:54\n     |\n2577 |     let group_span = Span { start: Position(0), end: Position(1) };\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n    --> regex-syntax/src/hir/translate.rs:2579:73\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                         ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `ast` in initializer of `ast::Repetition`\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                         ^^^^^^^^^^^^^^^ missing `ast`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:99\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2566 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:99\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: repetition_range }, greedy: false };\n     |                                                                                                   ^^^^^^^^^^^^^^^^ expected `RepetitionKind`, found `RepetitionRange`\n     |\nhelp: try wrapping the expression in `ast::RepetitionKind::Range`\n     |\n2579 |     let repetition_op = ast::Repetition { span: group_span.clone(), op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(repetition_range) }, greedy: false };\n     |                                                                                                   +++++++++++++++++++++++++++                +\n\nSome errors have detailed explanations: E0063, E0308, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: cls.iter().next().is_none() is true\n",
        "// expected return value/type: Err(self.error(\n                            ast.span, ErrorKind::EmptyClassNotAllowed))\n"
      ],
      "input_infer": "Test input ranges: ast as Ast::Class(ast::Class::Bracketed(ast)) with negated = true and empty class, flags set to unicode = true, self.pop().unwrap() results in HirFrame::ClassUnicode with an empty class.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockTranslator {",
                "        flags: Cell<Flags>,",
                "        stack: RefCell<Vec<HirFrame>>,",
                "        allow_invalid_utf8: bool,",
                "    }",
                "",
                "    impl MockTranslator {",
                "        fn new() -> Self {",
                "            Self {",
                "                flags: Cell::new(Flags {",
                "                    unicode: Some(true),",
                "                    ..Default::default()",
                "                }),",
                "                stack: RefCell::new(Vec::new()),",
                "                allow_invalid_utf8: false,",
                "            }",
                "        }",
                "    }",
                "",
                "    let translator = MockTranslator::new();",
                "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    let span = Span { start: 0, end: 1 };",
                "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ast::ClassSet::Normal,",
                "    });",
                "",
                "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                "",
                "    let ast = Ast::Class(class_bracketed);",
                "    ",
                "    let result = translator_i.visit_post(&ast);",
                "",
                "    // Test expects an error of kind EmptyClassNotAllowed.",
                "}"
              ],
              "oracles": [
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let mut stack = Vec::new();",
                  "    let mut translator = MockTranslator {",
                  "    flags: Cell::new(flags),",
                  "    stack: RefCell::new(stack),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Normal,",
                  "    });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let ast = Ast::Class(class_bracketed);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let mut stack = Vec::new();",
                  "    let mut translator = MockTranslator {",
                  "    flags: Cell::new(flags),",
                  "    stack: RefCell::new(stack),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Normal,",
                  "    });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let ast = Ast::Class(class_bracketed);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.err().unwrap();",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ast::ClassSet::Normal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "",
                  "    let ast = Ast::Class(class_bracketed);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Test expects an error of kind EmptyClassNotAllowed.",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let mut stack = Vec::new();",
                  "    let mut translator = MockTranslator {",
                  "    flags: Cell::new(flags),",
                  "    stack: RefCell::new(stack),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Normal,",
                  "    });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let ast = Ast::Class(class_bracketed);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ast::ClassSet::Normal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "",
                  "    let ast = Ast::Class(class_bracketed);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Test expects an error of kind EmptyClassNotAllowed.",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let mut stack = Vec::new();",
                  "    let mut translator = MockTranslator {",
                  "    flags: Cell::new(flags),",
                  "    stack: RefCell::new(stack),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Normal,",
                  "    });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let ast = Ast::Class(class_bracketed);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.err().unwrap();",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:30\n     |\n2566 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2584:45\n     |\n2584 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:30\n     |\n2585 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:38\n     |\n2585 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:26\n     |\n2589 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:30\n     |\n2566 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2584:45\n     |\n2584 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:30\n     |\n2585 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:38\n     |\n2585 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2589:26\n     |\n2589 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockTranslator {",
                "        flags: Cell<Flags>,",
                "        stack: RefCell<Vec<HirFrame>>,",
                "        allow_invalid_utf8: bool,",
                "    }",
                "",
                "    impl MockTranslator {",
                "        fn new() -> Self {",
                "            Self {",
                "                flags: Cell::new(Flags {",
                "                    unicode: Some(true),",
                "                    ..Default::default()",
                "                }),",
                "                stack: RefCell::new(Vec::new()),",
                "                allow_invalid_utf8: false,",
                "            }",
                "        }",
                "    }",
                "",
                "    let translator = MockTranslator::new();",
                "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    let span = Span { start: 0, end: 1 };",
                "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode {",
                "        span,",
                "        kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()),",
                "        negated: false,",
                "    });",
                "",
                "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    let ast = Ast::Class(unicode_class);",
                "    ",
                "    let result = translator_i.visit_post(&ast);",
                "",
                "    // Test expects an error of kind EmptyClassNotAllowed.",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let ast = Ast::Class(unicode_class);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let ast = Ast::Class(unicode_class);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::EmptyClassNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()),",
                  "        negated: false,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let ast = Ast::Class(unicode_class);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Test expects an error of kind EmptyClassNotAllowed.",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let ast = Ast::Class(unicode_class);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()),",
                  "        negated: false,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let ast = Ast::Class(unicode_class);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Test expects an error of kind EmptyClassNotAllowed.",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let ast = Ast::Class(unicode_class);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:30\n     |\n2576 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:38\n     |\n2576 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:30\n     |\n2576 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:38\n     |\n2576 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockTranslator {",
                "        flags: Cell<Flags>,",
                "        stack: RefCell<Vec<HirFrame>>,",
                "        allow_invalid_utf8: bool,",
                "    }",
                "",
                "    impl MockTranslator {",
                "        fn new() -> Self {",
                "            Self {",
                "                flags: Cell::new(Flags {",
                "                    unicode: Some(true),",
                "                    ..Default::default()",
                "                }),",
                "                stack: RefCell::new(Vec::new()),",
                "                allow_invalid_utf8: false,",
                "            }",
                "        }",
                "    }",
                "",
                "    let translator = MockTranslator::new();",
                "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = ast::Literal {",
                "        span,",
                "        c: 'a',",
                "        kind: ast::LiteralKind::Normal,",
                "    };",
                "",
                "    let ast = Ast::Literal(literal);",
                "    ",
                "    let result = translator_i.visit_post(&ast);",
                "",
                "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                "}"
              ],
              "oracles": [
                [
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Literal(literal.clone()));"
                ],
                [
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    assert!(class_bracketed_result.is_err());"
                ],
                [
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert!(empty_class.iter().next().is_none());"
                ],
                [
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    }));",
                  "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
                  "    assert!(class_unicode_result.is_err());"
                ],
                [
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    }));",
                  "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
                  "    let class_perl_ast = Ast::Class(ast::Class::Perl(ast::ClassPerl {",
                  "    span,",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    }));",
                  "    let class_perl_result = translator_i.visit_post(&class_perl_ast);",
                  "    assert!(class_perl_result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        c: 'a',",
                  "        kind: ast::LiteralKind::Normal,",
                  "    };",
                  "",
                  "    let ast = Ast::Literal(literal);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        c: 'a',",
                  "        kind: ast::LiteralKind::Normal,",
                  "    };",
                  "",
                  "    let ast = Ast::Literal(literal);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Literal(literal.clone()));",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        c: 'a',",
                  "        kind: ast::LiteralKind::Normal,",
                  "    };",
                  "",
                  "    let ast = Ast::Literal(literal);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    assert!(class_bracketed_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        c: 'a',",
                  "        kind: ast::LiteralKind::Normal,",
                  "    };",
                  "",
                  "    let ast = Ast::Literal(literal);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert!(empty_class.iter().next().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        c: 'a',",
                  "        kind: ast::LiteralKind::Normal,",
                  "    };",
                  "",
                  "    let ast = Ast::Literal(literal);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    }));",
                  "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
                  "    assert!(class_unicode_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        flags: Cell<Flags>,",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(true),",
                  "                    ..Default::default()",
                  "                }),",
                  "                stack: RefCell::new(Vec::new()),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let translator = MockTranslator::new();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        c: 'a',",
                  "        kind: ast::LiteralKind::Normal,",
                  "    };",
                  "",
                  "    let ast = Ast::Literal(literal);",
                  "    ",
                  "    let result = translator_i.visit_post(&ast);",
                  "",
                  "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
                  "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
                  "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
                  "    let expr = translator_i.pop().unwrap().unwrap_expr();",
                  "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
                  "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    }));",
                  "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
                  "    let class_perl_ast = Ast::Class(ast::Class::Perl(ast::ClassPerl {",
                  "    span,",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    }));",
                  "    let class_perl_result = translator_i.visit_post(&class_perl_ast);",
                  "    assert!(class_perl_result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |         kind: ast::LiteralKind::Normal,\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:51\n     |\n2574 |     translator_i.push(HirFrame::Expr(Hir::literal(literal)));\n     |                                      ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                      |\n     |                                      arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2577:30\n     |\n2577 |     assert_eq!(expr.kind(), &HirKind::Literal(literal.clone()));\n     |                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |         kind: ast::LiteralKind::Normal,\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:51\n     |\n2574 |     translator_i.push(HirFrame::Expr(Hir::literal(literal)));\n     |                                      ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                      |\n     |                                      arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |         kind: ast::LiteralKind::Normal,\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:51\n     |\n2574 |     translator_i.push(HirFrame::Expr(Hir::literal(literal)));\n     |                                      ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                      |\n     |                                      arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2580:26\n     |\n2580 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |         kind: ast::LiteralKind::Normal,\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:51\n     |\n2574 |     translator_i.push(HirFrame::Expr(Hir::literal(literal)));\n     |                                      ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                      |\n     |                                      arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2580:26\n     |\n2580 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |         kind: ast::LiteralKind::Normal,\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:51\n     |\n2574 |     translator_i.push(HirFrame::Expr(Hir::literal(literal)));\n     |                                      ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                      |\n     |                                      arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2580:26\n     |\n2580 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:45\n     |\n2560 |     let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");\n     |                            ---------------- ^^^^^^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                            |\n     |                            arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:30\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:38\n     |\n2562 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |         kind: ast::LiteralKind::Normal,\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2574:51\n     |\n2574 |     translator_i.push(HirFrame::Expr(Hir::literal(literal)));\n     |                                      ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                      |\n     |                                      arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2580:26\n     |\n2580 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: cls.iter().next().is_none() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "ast: Ast::Class(ast::Class::Unicode(ref x)), ast: Ast::Literal(ref x), ast: Ast::Class(ast::Class::Bracketed(ref ast)), self.flags().unicode() = true, self.pop().unwrap() is not None, cls.iter().next().is_none() = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let mut visitor = TranslatorI::new(&translator, \"\");",
                "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    assert!(visitor.trans().stack.borrow().is_empty());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.pop().unwrap().kind(), HirKind::Empty);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    assert!(visitor.trans().stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.pop().unwrap().kind(), HirKind::Empty);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:40\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:40\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:51\n     |\n2547 |     assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));\n     |                                                   ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:40\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |     assert_eq!(visitor.pop().unwrap().kind(), HirKind::Empty);\n     |                                               ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:40\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2544:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2544 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0599]: no method named `kind` found for enum `HirFrame` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:39\n     |\n154  | enum HirFrame {\n     | ------------- method `kind` not found for this enum\n...\n2547 |     assert_eq!(visitor.pop().unwrap().kind(), HirKind::Empty);\n     |                                       ^^^^ method not found in `HirFrame`\n     |\nnote: the method `kind` exists on the type `Hir`\n    --> regex-syntax/src/hir/mod.rs:205:5\n     |\n205  |     pub fn kind(&self) -> &HirKind {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                "    let literal = Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: LiteralKind::Unicode,",
                "        c: 'a',",
                "    };",
                "    let ast = Ast::Literal(literal);",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast_unicode = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    visitor.visit_post(&ast_unicode).unwrap();",
                  "    let class_perl = ClassPerl {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(ast::Class::Perl(class_perl));",
                  "    visitor.visit_post(&ast_perl).unwrap();",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed = Ast::Class(class_bracketed);",
                  "    if visitor.flags().unicode() {",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast_unicode = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    visitor.visit_post(&ast_unicode).unwrap();",
                  "    let class_perl = ClassPerl {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(ast::Class::Perl(class_perl));",
                  "    visitor.visit_post(&ast_perl).unwrap();",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed = Ast::Class(class_bracketed);",
                  "    if visitor.flags().unicode() {",
                  "    }",
                  "    visitor.visit_post(&ast_bracketed).unwrap();",
                  "    let class_bracketed_negated = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed_negated = Ast::Class(class_bracketed_negated);",
                  "    if visitor.flags().unicode() {",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast_unicode = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    visitor.visit_post(&ast_unicode).unwrap();",
                  "    let class_perl = ClassPerl {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(ast::Class::Perl(class_perl));",
                  "    visitor.visit_post(&ast_perl).unwrap();",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed = Ast::Class(class_bracketed);",
                  "    if visitor.flags().unicode() {",
                  "    }",
                  "    visitor.visit_post(&ast_bracketed).unwrap();",
                  "    let class_bracketed_negated = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed_negated = Ast::Class(class_bracketed_negated);",
                  "    if visitor.flags().unicode() {",
                  "    }",
                  "    let result = visitor.visit_post(&ast_bracketed_negated);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: LiteralKind::Unicode,",
                  "        c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast_unicode = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    visitor.visit_post(&ast_unicode).unwrap();",
                  "    let class_perl = ClassPerl {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(ast::Class::Perl(class_perl));",
                  "    visitor.visit_post(&ast_perl).unwrap();",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed = Ast::Class(class_bracketed);",
                  "    if visitor.flags().unicode() {",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: LiteralKind::Unicode,",
                  "        c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast_unicode = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    visitor.visit_post(&ast_unicode).unwrap();",
                  "    let class_perl = ClassPerl {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(ast::Class::Perl(class_perl));",
                  "    visitor.visit_post(&ast_perl).unwrap();",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed = Ast::Class(class_bracketed);",
                  "    if visitor.flags().unicode() {",
                  "    }",
                  "    visitor.visit_post(&ast_bracketed).unwrap();",
                  "    let class_bracketed_negated = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed_negated = Ast::Class(class_bracketed_negated);",
                  "    if visitor.flags().unicode() {",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: LiteralKind::Unicode,",
                  "        c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let literal = Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: LiteralKind::Unicode,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast_unicode = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    visitor.visit_post(&ast_unicode).unwrap();",
                  "    let class_perl = ClassPerl {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(ast::Class::Perl(class_perl));",
                  "    visitor.visit_post(&ast_perl).unwrap();",
                  "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed = Ast::Class(class_bracketed);",
                  "    if visitor.flags().unicode() {",
                  "    }",
                  "    visitor.visit_post(&ast_bracketed).unwrap();",
                  "    let class_bracketed_negated = ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    });",
                  "    let ast_bracketed_negated = Ast::Class(class_bracketed_negated);",
                  "    if visitor.flags().unicode() {",
                  "    }",
                  "    let result = visitor.visit_post(&ast_bracketed_negated);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2577:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2577 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2586:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2586 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:19\n     |\n2542 |     let literal = Literal {\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: LiteralKind::Unicode,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:19\n     |\n2551 |     let literal = Literal {\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:11\n     |\n2553 |     kind: LiteralKind::Unicode,\n     |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2558:25\n     |\n2558 |     let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:22\n     |\n2561 |     let class_perl = ClassPerl {\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: ClassPerlKind::Digit,\n     |           ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2571:11\n     |\n2571 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2580:11\n     |\n2580 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:29\n     |\n2543 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:37\n     |\n2543 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2549 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:25\n     |\n2552 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:33\n     |\n2562 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2578:25\n     |\n2578 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2578:33\n     |\n2578 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    assert!(matches!(result, HirFrame::Expr(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    assert!(matches!(expr.kind(), HirKind::Class(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    assert!(matches!(class, Class::Unicode(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    assert!(class_enum.iter().next().is_some());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    let pushed_expr = visitor.pop().unwrap();",
                  "    assert!(matches!(pushed_expr, HirFrame::ClassUnicode(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    let pushed_expr = visitor.pop().unwrap();",
                  "    let unicode_class_pushed = pushed_expr.unwrap_class_unicode();",
                  "    assert!(!unicode_class_pushed.is_empty());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    let pushed_expr = visitor.pop().unwrap();",
                  "    let unicode_class_pushed = pushed_expr.unwrap_class_unicode();",
                  "    assert_eq!(unicode_class_pushed.ranges().len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    assert!(matches!(result, HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    assert!(matches!(expr.kind(), HirKind::Class(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    assert!(matches!(class, Class::Unicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    assert!(class_enum.iter().next().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    let pushed_expr = visitor.pop().unwrap();",
                  "    assert!(matches!(pushed_expr, HirFrame::ClassUnicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    let pushed_expr = visitor.pop().unwrap();",
                  "    let unicode_class_pushed = pushed_expr.unwrap_class_unicode();",
                  "    assert!(!unicode_class_pushed.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.pop().unwrap();",
                  "    let expr = result.unwrap_expr();",
                  "    let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };",
                  "    let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };",
                  "    let pushed_expr = visitor.pop().unwrap();",
                  "    let unicode_class_pushed = pushed_expr.unwrap_class_unicode();",
                  "    assert_eq!(unicode_class_pushed.ranges().len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2552:35\n     |\n2552 |     assert!(matches!(expr.kind(), HirKind::Class(_)));\n     |                                   ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2552:24\n     |\n2552 |     let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     assert!(matches!(class, Class::Unicode(_)));\n     |                             ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2552:24\n     |\n2552 |     let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };\n     |                             ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2552:24\n     |\n2552 |     let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };\n     |                             ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2552:24\n     |\n2552 |     let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };\n     |                             ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no method named `is_empty` found for struct `hir::ClassUnicode` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:35\n     |\n2556 |     assert!(!unicode_class_pushed.is_empty());\n     |                                   ^^^^^^^^ method not found in `ClassUnicode`\n     |\n    ::: regex-syntax/src/hir/mod.rs:720:1\n     |\n720  | pub struct ClassUnicode {\n     | ----------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `is_empty`, perhaps you need to implement it:\n             candidate #1: `ExactSizeIterator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2542:25\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2543:26\n     |\n2543 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2548:26\n     |\n2548 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2552:24\n     |\n2552 |     let class = if let HirKind::Class(class) = expr.kind() { class } else { panic!(\"Expected HirKind::Class\") };\n     |                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     let class_enum = if let Class::Unicode(cls) = class { cls } else { panic!(\"Expected Class::Unicode\") };\n     |                             ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2545 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                "    let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                "    class_bytes.push(ClassBytesRange { start: 1, end: 1 });",
                "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                "        span: Span { start: 0, end: 1 },",
                "        negated: false,",
                "        kind: ClassSet::Default,",
                "    }));",
                "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 1 },",
                  "    negated: false,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    assert!(visitor.pop().unwrap().unwrap_class_bytes().ranges().len() > 0);"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 1 },",
                  "    negated: false,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    assert!(visitor.visit_post(&ast).is_ok());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 1 },",
                  "    negated: false,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Class(Class::Bracketed(ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Default })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    class_bytes.push(ClassBytesRange { start: 1, end: 1 });",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 1 },",
                  "        negated: false,",
                  "        kind: ClassSet::Default,",
                  "    }));",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 1 },",
                  "    negated: false,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    assert!(visitor.pop().unwrap().unwrap_class_bytes().ranges().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    class_bytes.push(ClassBytesRange { start: 1, end: 1 });",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 1 },",
                  "        negated: false,",
                  "        kind: ClassSet::Default,",
                  "    }));",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 1 },",
                  "    negated: false,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    assert!(visitor.visit_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    class_bytes.push(ClassBytesRange { start: 1, end: 1 });",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 1 },",
                  "        negated: false,",
                  "        kind: ClassSet::Default,",
                  "    }));",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let mut visitor = TranslatorI::new(&translator, \"abc\");",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    visitor.push(HirFrame::ClassBytes(class_bytes));",
                  "    let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {",
                  "    span: Span { start: 0, end: 1 },",
                  "    negated: false,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Class(Class::Bracketed(ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Default })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                           ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                                ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     class_bytes.push(ClassBytesRange { start: 1, end: 1 });\n     |                      ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2544:26\n     |\n2544 |     let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: ClassSet::Default,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2558:11\n     |\n2558 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:29\n     |\n2545 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:37\n     |\n2545 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:25\n     |\n2556 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:33\n     |\n2556 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                           ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                                ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     class_bytes.push(ClassBytesRange { start: 1, end: 1 });\n     |                      ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2544:26\n     |\n2544 |     let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: ClassSet::Default,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2558:11\n     |\n2558 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:29\n     |\n2545 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:37\n     |\n2545 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:25\n     |\n2556 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:33\n     |\n2556 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2542:27\n     |\n2542 |     let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                           ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2542:48\n     |\n2542 |     let mut class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                                ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:22\n     |\n2543 |     class_bytes.push(ClassBytesRange { start: 1, end: 1 });\n     |                      ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2544:26\n     |\n2544 |     let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2547:15\n     |\n2547 |         kind: ClassSet::Default,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Class(Class::Bracketed(ast::ClassBracketed {\n     |                          ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2558:11\n     |\n2558 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2560:62\n     |\n2560 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Class(Class::Bracketed(ast::ClassBracketed { span: Span { start: 0,...\n     |                                                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2560:77\n     |\n2560 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Class(Class::Bracketed(ast::ClassBracketed { span: Span { start: 0,...\n     |                                                                             ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2560:171\n     |\n2560 | ...n { start: 0, end: 1 }, negated: false, kind: ClassSet::Default })));\n     |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:29\n     |\n2545 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2545:37\n     |\n2545 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:25\n     |\n2556 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:33\n     |\n2556 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:136\n     |\n2560 | ...cketed(ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Default })));\n     |                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:144\n     |\n2560 | ...st::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Default })));\n     |                                                     ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.bytes_fold_and_negate(\n                        &ast.span, ast.negated, &mut cls)? is Err/None\n"
      ],
      "input_infer": "Ast::Class(ast::Class::Bracketed(ref ast)) with negated=true and empty ranges, Ast::Literal(ref x) with non-ASCII characters, self.flags().unicode()=false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"[^]\";",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span { start: 0, end: 3 };",
                "    let class_bracketed = ast::ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ast::ClassSet::Bracketed(vec![]),",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                "    let result = translator_i.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Bracketed(vec![]),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Bracketed(vec![]),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::EmptyClassNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let class_bracketed = ast::ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ast::ClassSet::Bracketed(vec![]),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Bracketed(vec![]),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let class_bracketed = ast::ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ast::ClassSet::Bracketed(vec![]),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ast::ClassSet::Bracketed(vec![]),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Bracketed` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |         kind: ast::ClassSet::Bracketed(vec![]),\n     |                              ^^^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Bracketed` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Bracketed` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:26\n     |\n2569 |     kind: ast::ClassSet::Bracketed(vec![]),\n     |                          ^^^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Bracketed` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Bracketed` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |         kind: ast::ClassSet::Bracketed(vec![]),\n     |                              ^^^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Bracketed` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Bracketed` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:26\n     |\n2569 |     kind: ast::ClassSet::Bracketed(vec![]),\n     |                          ^^^^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Bracketed` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"\"; // Non-ASCII characters",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span { start: 0, end: 3 };",
                "    let literal = ast::Literal {",
                "        span,",
                "        kind: ast::LiteralKind::Unicode,",
                "        c: '',",
                "    };",
                "    ",
                "    let ast = Ast::Literal(literal);",
                "    let result = translator_i.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(translator_i.pop().is_some(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(translator_i.stack.borrow().len() > 0);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().case_insensitive, None);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().multi_line, None);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().dot_matches_new_line, None);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().swap_greed, None);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().unicode, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(translator_i.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(translator_i.stack.borrow().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().case_insensitive, None);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().multi_line, None);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().dot_matches_new_line, None);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().swap_greed, None);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "        span,",
                  "        kind: ast::LiteralKind::Unicode,",
                  "        c: '',",
                  "    };",
                  "    ",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\"; // Non-ASCII characters",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Unicode,",
                  "    c: '',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(trans.flags.get().unicode, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2573:26\n     |\n2573 |     assert!(translator_i.stack.borrow().len() > 0);\n     |                          ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2573 |     assert!(translator_i.trans.stack.borrow().len() > 0);\n     |                          ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2552:33\n     |\n2552 |         kind: ast::LiteralKind::Unicode,\n     |                                 ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 3 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Unicode` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     kind: ast::LiteralKind::Unicode,\n     |                             ^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Unicode` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"[abc]\";",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span { start: 0, end: 5 };",
                "    let unicode_class = ast::ClassUnicode {",
                "        span,",
                "        negated: false,",
                "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                "    let result = translator_i.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodeNotAllowed);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::EmptyClassNotAllowed);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Normal,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Normal,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(!translator_i.trans().stack.borrow().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Normal,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[abc]\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let literal = ast::Literal {",
                  "    span,",
                  "    kind: ast::LiteralKind::Normal,",
                  "    c: 'a',",
                  "    };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(!translator_i.trans().stack.borrow().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2576:26\n     |\n2576 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2576:26\n     |\n2576 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2576:26\n     |\n2576 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2581:29\n     |\n2581 |     kind: ast::LiteralKind::Normal,\n     |                             ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:30\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:38\n     |\n2565 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2576:26\n     |\n2576 |     kind: ast::ClassSet::Normal,\n     |                          ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2581:29\n     |\n2581 |     kind: ast::LiteralKind::Normal,\n     |                             ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 14,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.bytes_fold_and_negate(\n                        &ast.span, ast.negated, &mut cls)? is Ok/Some\n",
        "// constraint: cls.iter().next().is_none() is true\n",
        "// expected return value/type: Err(self.error(\n                            ast.span, ErrorKind::EmptyClassNotAllowed))\n"
      ],
      "input_infer": "1. Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 0, end: 1 }, negated: false, kind: ClassSet::Normal })) with self.flags().unicode() == false, and cls is an empty ClassBytes.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let brief_class_bracketed = ast::ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Normal,",
                "    };",
                "    ",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                "    ",
                "    let result = {",
                "        let mut visitor = TranslatorI::new(&translator, \"\");",
                "        visitor.visit_post(&bracketed_class_ast);",
                "    };",
                "    ",
                "    // handle the expected result here without assertions or oracles.",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.pattern, \"\");"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    ",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    ",
                  "    // handle the expected result here without assertions or oracles.",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    ",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    ",
                  "    // handle the expected result here without assertions or oracles.",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    ",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    ",
                  "    // handle the expected result here without assertions or oracles.",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.pattern, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    ",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    ",
                  "    // handle the expected result here without assertions or oracles.",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let brief_class_bracketed = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let bracketed_class_ast = Ast::Class(ast::Class::Bracketed(brief_class_bracketed));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&bracketed_class_ast);",
                  "    };",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2565:11\n     |\n2565 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:38\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `is_err` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2577:20\n     |\n2577 |     assert!(result.is_err());\n     |                    ^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2565:11\n     |\n2565 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:38\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `unwrap_err` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2577:24\n     |\n2577 |     let error = result.unwrap_err();\n     |                        ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2565:11\n     |\n2565 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:38\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `unwrap_err` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2577:24\n     |\n2577 |     let error = result.unwrap_err();\n     |                        ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2565:11\n     |\n2565 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:38\n     |\n2561 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `unwrap_err` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2577:24\n     |\n2577 |     let error = result.unwrap_err();\n     |                        ^^^^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                "",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                "",
                "    let result = {",
                "        let mut visitor = TranslatorI::new(&translator, \"\");",
                "        visitor.visit_post(&perl_class_ast);",
                "    };",
                "    ",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = Vec::new();",
                  "    assert!(stack.is_empty());"
                ],
                [
                  "    let mut stack = Vec::new();",
                  "    assert_eq!(translator.allow_invalid_utf8, false);"
                ],
                [
                  "    let mut stack = Vec::new();",
                  "    assert_eq!(translator.flags.get().unicode, Some(false));"
                ],
                [
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);"
                ],
                [
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.pattern, \"\");"
                ],
                [
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    assert!(stack.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    assert_eq!(translator.allow_invalid_utf8, false);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    assert_eq!(translator.flags.get().unicode, Some(false));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.pattern, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let perl_class = ast::ClassPerl { span, kind: ast::ClassPerlKind::Word, negated: false };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let perl_class_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&perl_class_ast);",
                  "    };",
                  "    ",
                  "    let mut stack = Vec::new();",
                  "    let result = visitor.visit_post(&perl_class_ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `visitor` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:18\n     |\n2557 |     let result = visitor.visit_post(&perl_class_ast);\n     |                  ^^^^^^^\n     |\nhelp: the binding `visitor` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2552:17\n     |\n2552 |         let mut visitor = TranslatorI::new(&translator, \"\");\n     |                 ^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `visitor` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:18\n     |\n2557 |     let result = visitor.visit_post(&perl_class_ast);\n     |                  ^^^^^^^\n     |\nhelp: the binding `visitor` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2552:17\n     |\n2552 |         let mut visitor = TranslatorI::new(&translator, \"\");\n     |                 ^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `visitor` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:18\n     |\n2557 |     let result = visitor.visit_post(&perl_class_ast);\n     |                  ^^^^^^^\n     |\nhelp: the binding `visitor` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2552:17\n     |\n2552 |         let mut visitor = TranslatorI::new(&translator, \"\");\n     |                 ^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `visitor` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:18\n     |\n2557 |     let result = visitor.visit_post(&perl_class_ast);\n     |                  ^^^^^^^\n     |\nhelp: the binding `visitor` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2552:17\n     |\n2552 |         let mut visitor = TranslatorI::new(&translator, \"\");\n     |                 ^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let unicode_class = ast::ClassUnicode {",
                "        span,",
                "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                "        negated: false,",
                "    };",
                "",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                "",
                "    let result = {",
                "        let mut visitor = TranslatorI::new(&translator, \"\");",
                "        visitor.visit_post(&unicode_class_ast);",
                "    };",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    match result {",
                  "    Err(error) => {",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    match result {",
                  "    Err(error) => {",
                  "    assert_eq!(error.pattern, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    match result {",
                  "    Err(error) => {",
                  "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "",
                  "    let result = {",
                  "        let mut visitor = TranslatorI::new(&translator, \"\");",
                  "        visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    let result = {",
                  "    let mut visitor = TranslatorI::new(&translator, \"\");",
                  "    visitor.visit_post(&unicode_class_ast);",
                  "    };",
                  "    match result {",
                  "    Err(error) => {",
                  "    assert_eq!(error.pattern, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:30\n     |\n2559 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:38\n     |\n2559 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `is_err` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2575:20\n     |\n2575 |     assert!(result.is_err());\n     |                    ^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2579:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2576 |     Err(error) => {\n     |                   - this delimiter might not be properly closed...\n2577 |     assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);\n2578 | }\n     | - ...as it matches this but it has different indentation\n2579 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2579:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2576 |     Err(error) => {\n     |                   - this delimiter might not be properly closed...\n2577 |     assert_eq!(error.pattern, \"\");\n2578 | }\n     | - ...as it matches this but it has different indentation\n2579 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.bytes_fold_and_negate(\n                        &ast.span, ast.negated, &mut cls)? is Ok/Some\n",
        "// constraint: cls.iter().next().is_none() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Class(ast::Class::Bracketed(ref ast)), Ast::Literal(ref x), self.flags().unicode() = false, self.pop().unwrap() = Some(HirFrame::ClassBytes(ClassBytes { set: IntervalSet::new() })), self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls) = Ok(()), cls.iter().next().is_none() = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(false),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = Literal {",
                "        span,",
                "        kind: LiteralKind::Character,",
                "        c: 'a',",
                "    };",
                "    ",
                "    let ast = Ast::Literal(literal);",
                "    ",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(false),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let span = Span { start: 0, end: 1 };",
                "",
                "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                "    let class = Class::Unicode(unicode_class);",
                "    let ast = Ast::Class(class);",
                "",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![",
                "        ClassBytesRange { start: 97, end: 122 },",
                "    ])));",
                "",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    assert!(translator.pop().is_some());"
                ],
                [
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    assert_eq!(translator.flags().unicode(), false);"
                ],
                [
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    assert!(translator.bytes_fold_and_negate(&span, false, &mut translator.pop().unwrap().unwrap_class_bytes()).is_ok());"
                ],
                [
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    let cls = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.iter().next().is_some());"
                ],
                [
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    let cls = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![",
                  "        ClassBytesRange { start: 97, end: 122 },",
                  "    ])));",
                  "",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    assert!(translator.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![",
                  "        ClassBytesRange { start: 97, end: 122 },",
                  "    ])));",
                  "",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    assert_eq!(translator.flags().unicode(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![",
                  "        ClassBytesRange { start: 97, end: 122 },",
                  "    ])));",
                  "",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    assert!(translator.bytes_fold_and_negate(&span, false, &mut translator.pop().unwrap().unwrap_class_bytes()).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![",
                  "        ClassBytesRange { start: 97, end: 122 },",
                  "    ])));",
                  "",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    let cls = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.iter().next().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: 0, end: 1 };",
                  "",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![",
                  "        ClassBytesRange { start: 97, end: 122 },",
                  "    ])));",
                  "",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.flags.set(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false) });",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);",
                  "    let class = Class::Unicode(unicode_class);",
                  "    let ast = Ast::Class(class);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));",
                  "    let cls = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:42\n     |\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:9\n     |\n2559 |         ClassBytesRange { start: 97, end: 122 },\n     |         ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:48\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:42\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:63\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                                               ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2562 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:38\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     assert!(translator.pop().is_some());\n     |                        ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:42\n     |\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:9\n     |\n2559 |         ClassBytesRange { start: 97, end: 122 },\n     |         ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:48\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:42\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:63\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                                               ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2562 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:38\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `flags` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `flags` not found for this struct\n...\n2569 |     assert_eq!(translator.flags().unicode(), false);\n     |                           ^^^^^-- help: remove the arguments\n     |                           |\n     |                           field, not a method\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:42\n     |\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:9\n     |\n2559 |         ClassBytesRange { start: 97, end: 122 },\n     |         ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:48\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:42\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:63\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                                               ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2562 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:38\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `bytes_fold_and_negate` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `bytes_fold_and_negate` not found for this struct\n...\n2569 |     assert!(translator.bytes_fold_and_negate(&span, false, &mut translator.pop().unwrap().unwrap_class_bytes()).is_ok());\n     |                        ^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:76\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     assert!(translator.bytes_fold_and_negate(&span, false, &mut translator.pop().unwrap().unwrap_class_bytes()).is_ok());\n     |                                                                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:42\n     |\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:9\n     |\n2559 |         ClassBytesRange { start: 97, end: 122 },\n     |         ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:48\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:42\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:63\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                                               ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2562 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:38\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:26\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     let cls = translator.pop().unwrap().unwrap_class_bytes();\n     |                          ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2558:42\n     |\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:9\n     |\n2559 |         ClassBytesRange { start: 97, end: 122 },\n     |         ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicodeRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:48\n     |\n2565 |     let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange { start: 'a', end: 'z' }]);\n     |                                                ^^^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassUnicodeRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2566:17\n     |\n2566 |     let class = Class::Unicode(unicode_class);\n     |                 ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:42\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:63\n     |\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                                                               ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2558 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![\n     |     -----------^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2562 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:38\n     |\n2564 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2568 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![ClassBytesRange { start: 97, end: 122 }])));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:26\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     let cls = translator.pop().unwrap().unwrap_class_bytes();\n     |                          ^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2570 |     assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));\n     |                           ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(false),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let span = Span { start: 0, end: 10 };",
                "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                "    let bracketed_class = ast::Class::Bracketed(ast::ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ast::ClassSet::Union,",
                "    });",
                "    ",
                "    let ast = Ast::Class(bracketed_class);",
                "    ",
                "    translator.push(HirFrame::ClassBytes(class_bytes));",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(translator.pop().is_some());"
                ],
                [
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(class_bytes)));"
                ],
                [
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert!(class_bytes.iter().next().is_some());"
                ],
                [
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert!(translator.flags().unicode() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    let bracketed_class = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union,",
                  "    });",
                  "    ",
                  "    let ast = Ast::Class(bracketed_class);",
                  "    ",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    let bracketed_class = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union,",
                  "    });",
                  "    ",
                  "    let ast = Ast::Class(bracketed_class);",
                  "    ",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(translator.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    let bracketed_class = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union,",
                  "    });",
                  "    ",
                  "    let ast = Ast::Class(bracketed_class);",
                  "    ",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(class_bytes)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    let bracketed_class = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union,",
                  "    });",
                  "    ",
                  "    let ast = Ast::Class(bracketed_class);",
                  "    ",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert!(class_bytes.iter().next().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);",
                  "    let bracketed_class = ast::Class::Bracketed(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union,",
                  "    });",
                  "    ",
                  "    let ast = Ast::Class(bracketed_class);",
                  "    ",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    translator.visit_post(&ast).unwrap();",
                  "    translator.push(HirFrame::ClassBytes(class_bytes));",
                  "    let result = translator.visit_post(&ast);",
                  "    let expr = translator.pop().unwrap().unwrap_expr();",
                  "    assert!(translator.flags().unicode() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                                      ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |         kind: ast::ClassSet::Union,\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nhelp: there is an associated function `union` with a similar name\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2562 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2565 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                                      ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |         kind: ast::ClassSet::Union,\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nhelp: there is an associated function `union` with a similar name\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2562 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2565 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2566 |     assert!(translator.pop().is_some());\n     |                        ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(class_bytes)));\n     |                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                                      ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |         kind: ast::ClassSet::Union,\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nhelp: there is an associated function `union` with a similar name\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2562 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2565 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2566 |     let expr = translator.pop().unwrap().unwrap_expr();\n     |                           ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                                      ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |         kind: ast::ClassSet::Union,\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nhelp: there is an associated function `union` with a similar name\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2562 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2565 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2566 |     let expr = translator.pop().unwrap().unwrap_expr();\n     |                           ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2553:23\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBytesRange` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:44\n     |\n2553 |     let class_bytes = ClassBytes::new(vec![ClassBytesRange { start: 0, end: 255 }]);\n     |                                            ^^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytesRange;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 10 };\n     |                                      ^^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |         kind: ast::ClassSet::Union,\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nhelp: there is an associated function `union` with a similar name\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2562 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2564 |     translator.push(HirFrame::ClassBytes(class_bytes));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2565 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:27\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2566 |     let expr = translator.pop().unwrap().unwrap_expr();\n     |                           ^^^ method not found in `Translator`\n\nerror[E0599]: no method named `flags` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `flags` not found for this struct\n...\n2567 |     assert!(translator.flags().unicode() == false);\n     |                        ^^^^^-- help: remove the arguments\n     |                        |\n     |                        field, not a method\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 16,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Flags(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Perl(ref x)) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Flags(ref x) where x must ensure that unicode is enabled alongside Ast::Class(ast::Class::Perl(ref x)) with specific properties leading to Ok(()) under the condition that self.flags().unicode() is true; spanning inputs such as Ast::Class::Perl::Digit, Ast::Class::Perl::Space and various combinations thereof, and complements thereof such as empty unicode classes with clear assertions on flags or the specific items involved ensuring proper byte ranges between 0 to 255 facilitating complete representation thereby covering for unicode properties range.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator { ",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().case_insensitive, None);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().multi_line, None);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().dot_matches_new_line, None);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().swap_greed, None);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().unicode, None);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    assert!(translator_i.flags().unicode());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    assert!(cls.iter().next().is_some());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    let hcls = hir::Class::Unicode(cls);",
                  "    translator_i.push(HirFrame::Expr(Hir::class(hcls)));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    translator_i.unicode_fold_and_negate(false, &mut cls);",
                  "    assert!(cls.iter().next().is_none());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    let hcls = hir::Class::Unicode(cls);",
                  "    translator_i.push(HirFrame::Expr(Hir::class(hcls)));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    translator_i.unicode_fold_and_negate(false, &mut cls);",
                  "    assert!(translator_i.visit_post(&ast).is_err());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    let hcls = hir::Class::Unicode(cls);",
                  "    translator_i.push(HirFrame::Expr(Hir::class(hcls)));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    translator_i.unicode_fold_and_negate(false, &mut cls);",
                  "    assert_eq!(translator_i.visit_post(&ast), Err(translator_i.error(ast.span, ErrorKind::EmptyClassNotAllowed)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().case_insensitive, None);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().multi_line, None);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().dot_matches_new_line, None);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().swap_greed, None);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    assert_eq!(translator_i.flags().unicode, None);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    assert!(translator_i.flags().unicode());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    assert!(cls.iter().next().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    let hcls = hir::Class::Unicode(cls);",
                  "    translator_i.push(HirFrame::Expr(Hir::class(hcls)));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    translator_i.unicode_fold_and_negate(false, &mut cls);",
                  "    assert!(cls.iter().next().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    let hcls = hir::Class::Unicode(cls);",
                  "    translator_i.push(HirFrame::Expr(Hir::class(hcls)));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    translator_i.unicode_fold_and_negate(false, &mut cls);",
                  "    assert!(translator_i.visit_post(&ast).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });",
                  "    translator_i.set_flags(&ast.flags);",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: false }));",
                  "    let cls = translator_i.hir_perl_unicode_class(&ast);",
                  "    let hcls = hir::Class::Unicode(cls);",
                  "    translator_i.push(HirFrame::Expr(Hir::class(hcls)));",
                  "    let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    translator_i.unicode_fold_and_negate(false, &mut cls);",
                  "    assert_eq!(translator_i.visit_post(&ast), Err(translator_i.error(ast.span, ErrorKind::EmptyClassNotAllowed)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:80\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:88\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                        ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:80\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:88\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:51\n     |\n2553 |     let cls = translator_i.hir_perl_unicode_class(&ast);\n     |                            ---------------------- ^^^^ expected `&ClassPerl`, found `&Ast`\n     |                            |\n     |                            arguments to this method are incorrect\n     |\n     = note: expected reference `&ClassPerl`\n                found reference `&ast::Ast`\nnote: method defined here\n    --> regex-syntax/src/hir/translate.rs:826:8\n     |\n826  |     fn hir_perl_unicode_class(\n     |        ^^^^^^^^^^^^^^^^^^^^^^\n827  |         &self,\n828  |         ast_class: &ast::ClassPerl,\n     |         --------------------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:125\n     |\n2556 | ...n { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));\n     |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:80\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:88\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:51\n     |\n2553 |     let cls = translator_i.hir_perl_unicode_class(&ast);\n     |                            ---------------------- ^^^^ expected `&ClassPerl`, found `&Ast`\n     |                            |\n     |                            arguments to this method are incorrect\n     |\n     = note: expected reference `&ClassPerl`\n                found reference `&ast::Ast`\nnote: method defined here\n    --> regex-syntax/src/hir/translate.rs:826:8\n     |\n826  |     fn hir_perl_unicode_class(\n     |        ^^^^^^^^^^^^^^^^^^^^^^\n827  |         &self,\n828  |         ast_class: &ast::ClassPerl,\n     |         --------------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:90\n     |\n2556 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Uni...\n     |                                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:98\n     |\n2556 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Uni...\n     |                                                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:125\n     |\n2556 | ...n { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));\n     |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:80\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:88\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:51\n     |\n2553 |     let cls = translator_i.hir_perl_unicode_class(&ast);\n     |                            ---------------------- ^^^^ expected `&ClassPerl`, found `&Ast`\n     |                            |\n     |                            arguments to this method are incorrect\n     |\n     = note: expected reference `&ClassPerl`\n                found reference `&ast::Ast`\nnote: method defined here\n    --> regex-syntax/src/hir/translate.rs:826:8\n     |\n826  |     fn hir_perl_unicode_class(\n     |        ^^^^^^^^^^^^^^^^^^^^^^\n827  |         &self,\n828  |         ast_class: &ast::ClassPerl,\n     |         --------------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:90\n     |\n2556 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Uni...\n     |                                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:98\n     |\n2556 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Uni...\n     |                                                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:26\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                          ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:125\n     |\n2556 | ...n { start: 2, end: 3 }, negated: false, kind: ClassSet::Union }));\n     |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:40\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:57\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2550:65\n     |\n2550 |     let ast = Ast::Flags(SetFlags { span: Span { start: 0, end: 0 }, flags: Flags::default() });\n     |                                                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `flags` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2551:33\n     |\n2551 |     translator_i.set_flags(&ast.flags);\n     |                                 ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:80\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:88\n     |\n2552 |     let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl { span: Span { start: 0, end: 1 }, kind: ast::ClassPerlKind::Word, negated: fals...\n     |                                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:51\n     |\n2553 |     let cls = translator_i.hir_perl_unicode_class(&ast);\n     |                            ---------------------- ^^^^ expected `&ClassPerl`, found `&Ast`\n     |                            |\n     |                            arguments to this method are incorrect\n     |\n     = note: expected reference `&ClassPerl`\n                found reference `&ast::Ast`\nnote: method defined here\n    --> regex-syntax/src/hir/translate.rs:826:8\n     |\n826  |     fn hir_perl_unicode_class(\n     |        ^^^^^^^^^^^^^^^^^^^^^^\n827  |         &self,\n828  |         ast_class: &ast::ClassPerl,\n     |         --------------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:90\n     |\n2556 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Uni...\n     |                                                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:98\n     |\n2556 |     let ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed { span: Span { start: 2, end: 3 }, negated: false, kind: ClassSet::Uni...\n     |                                                                                                  ^ expected `Position`, found integer\n\nerror[E0609]: no field `span` on type `ast::Ast`\n    --> regex-syntax/src/hir/translate.rs:2559:74\n     |\n2559 |     assert_eq!(translator_i.visit_post(&ast), Err(translator_i.error(ast.span, ErrorKind::EmptyClassNotAllowed)));\n     |                                                                          ^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator { ",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                "    let ast = Ast::Flags(flags);",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.trans.stack.borrow().is_empty());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.flags().case_insensitive, Some(true));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.flags().unicode(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.trans.stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.flags().case_insensitive, Some(true));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(true)}};",
                  "    let ast = Ast::Flags(flags);",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.flags().unicode(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:17\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                        ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:17\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                        ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:17\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:17\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::SetFlags;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:56\n     |\n2546 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |     let flags = SetFlags { span: Span { start: 0, end: 1 }, flags: Flags { case_insensitive: Some(true), multi_line: None, dot_matches_ne...\n     |                                                        ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator { ",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };",
                "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_stack = translator.stack.borrow().clone();",
                  "    let expected_flags = translator.flags.get();",
                  "    let expected_hir = Hir::class(hir::Class::Unicode(translator_i.hir_perl_unicode_class(&perl_class)));",
                  "    assert_eq!(expected_stack.len(), 1);"
                ],
                [
                  "    let expected_stack = translator.stack.borrow().clone();",
                  "    let expected_flags = translator.flags.get();",
                  "    let expected_hir = Hir::class(hir::Class::Unicode(translator_i.hir_perl_unicode_class(&perl_class)));",
                  "    assert_eq!(expected_stack[0], HirFrame::Expr(expected_hir));"
                ],
                [
                  "    let expected_stack = translator.stack.borrow().clone();",
                  "    let expected_flags = translator.flags.get();",
                  "    let expected_hir = Hir::class(hir::Class::Unicode(translator_i.hir_perl_unicode_class(&perl_class)));",
                  "    assert_eq!(expected_flags.unicode(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let expected_stack = translator.stack.borrow().clone();",
                  "    let expected_flags = translator.flags.get();",
                  "    let expected_hir = Hir::class(hir::Class::Unicode(translator_i.hir_perl_unicode_class(&perl_class)));",
                  "    assert_eq!(expected_stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let expected_stack = translator.stack.borrow().clone();",
                  "    let expected_flags = translator.flags.get();",
                  "    let expected_hir = Hir::class(hir::Class::Unicode(translator_i.hir_perl_unicode_class(&perl_class)));",
                  "    assert_eq!(expected_stack[0], HirFrame::Expr(expected_hir));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator { ",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let expected_stack = translator.stack.borrow().clone();",
                  "    let expected_flags = translator.flags.get();",
                  "    let expected_hir = Hir::class(hir::Class::Unicode(translator_i.hir_perl_unicode_class(&perl_class)));",
                  "    assert_eq!(expected_flags.unicode(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:22\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2546:73\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                                         ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:62\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:22\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2546:73\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                                         ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:62\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                              ^ expected `Position`, found integer\n\nerror[E0369]: binary operation `==` cannot be applied to type `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:2552:5\n     |\n2552 |     assert_eq!(expected_stack[0], HirFrame::Expr(expected_hir));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     translate::HirFrame\n     |     translate::HirFrame\n     |\nnote: an implementation of `PartialEq` might be missing for `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:154:1\n     |\n154  | enum HirFrame {\n     | ^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `translate::HirFrame` with `#[derive(PartialEq)]`\n     |\n154  + #[derive(PartialEq)]\n155  | enum HirFrame {\n     |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0369, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:22\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2546:73\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                                         ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:54\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:62\n     |\n2546 |     let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Digit, negated: false };\n     |                                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let perl_class = ClassPerl { span: Span { start: 0, end: 1 }, kind: ClassPerlKind::Space, negated: false };",
                "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.pop().is_some(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.stack.borrow().len(), 1);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.flags().unicode(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.flags().unicode(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2546:95\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2555:95\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:60\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:68\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:60\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:68\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2546:95\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2555:95\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:60\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:68\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:60\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:68\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2558:29\n     |\n2558 |     assert_eq!(translator_i.stack.borrow().len(), 1);\n     |                             ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2558 |     assert_eq!(translator_i.trans.stack.borrow().len(), 1);\n     |                             ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2546:95\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2555:95\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                                               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:60\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:68\n     |\n2546 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                    ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:60\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:68\n     |\n2555 |     let unicode_class = ClassUnicode { span: Span { start: 0, end: 1 }, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n     |                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let bracketed_class = ClassBracketed {",
                "        span: Span { start: 0, end: 2 },",
                "        negated: false,",
                "        kind: ClassSet::Normal,",
                "    };",
                "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.pop().is_some());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.stack.borrow().is_empty());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.flags().unicode());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.trans().flags.get().unicode.is_some());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().flags.get().unicode, Some(true));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.unicode());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.multi_line.is_none());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.dot_matches_new_line.is_none());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.swap_greed.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.flags().unicode());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert!(translator_i.trans().flags.get().unicode.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.trans().flags.get().unicode, Some(true));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.unicode());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.multi_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.dot_matches_new_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span { start: 0, end: 2 },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span { start: 0, end: 2 },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let flags_set = translator_i.flags();",
                  "    assert!(flags_set.swap_greed.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2566:26\n     |\n2566 |     assert!(translator_i.stack.borrow().is_empty());\n     |                          ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2566 |     assert!(translator_i.trans.stack.borrow().is_empty());\n     |                          ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:27\n     |\n2546 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:27\n     |\n2559 |     let bracketed_class = ClassBracketed {\n     |                           ^^^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassBracketed;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:37\n     |\n2547 |         span: Span { start: 0, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:33\n     |\n2560 |     span: Span { start: 0, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 17,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Flags(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Perl(ref x)) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Flags(ref x); Ast::Class(ast::Class::Perl(ref x)); self.flags().unicode() = false; x.flags = valid_flags(); x.kind = valid_perl_class();\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let flags = Flags {",
                "        case_insensitive: Some(false),",
                "        multi_line: Some(false),",
                "        dot_matches_new_line: Some(false),",
                "        swap_greed: Some(false),",
                "        unicode: Some(false),",
                "    };",
                "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                "    let perl_class = ast::ClassPerl {",
                "        span,",
                "        kind: ast::ClassPerlKind::Digit,",
                "        negated: false,",
                "    };",
                "    let ast = Ast::Flags(ast_flags);",
                "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    visitor.visit_post(&ast).unwrap();",
                "    visitor.visit_post(&perl_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.case_insensitive, Some(false));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.multi_line, Some(false));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.dot_matches_new_line, Some(false));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.swap_greed, Some(false));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.unicode, Some(false));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    assert!(visitor.pop().is_none());"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Flags(_));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(!visitor.trans().stack.borrow().is_empty());"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let perl_expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(perl_expr.kind(), &HirKind::Class(Hir::class(hir::Class::Bytes(_))));"
                ],
                [
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let perl_expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().stack.borrow().len() >= 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.case_insensitive, Some(false));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.multi_line, Some(false));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.dot_matches_new_line, Some(false));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.swap_greed, Some(false));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    assert_eq!(flags.unicode, Some(false));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Flags(_));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(!visitor.trans().stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let perl_expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(perl_expr.kind(), &HirKind::Class(Hir::class(hir::Class::Bytes(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let perl_class = ast::ClassPerl {",
                  "        span,",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let perl_ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&perl_ast).unwrap();",
                  "    let flags = visitor.flags();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let perl_expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().stack.borrow().len() >= 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     assert_eq!(expr.kind(), &HirKind::Flags(_));\n     |                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> regex-syntax/src/hir/translate.rs:2568:45\n     |\n2568 |     assert_eq!(expr.kind(), &HirKind::Flags(_));\n     |                                             ^ `_` not allowed here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2569:35\n     |\n2569 |     assert_eq!(perl_expr.kind(), &HirKind::Class(Hir::class(hir::Class::Bytes(_))));\n     |                                   ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> regex-syntax/src/hir/translate.rs:2569:79\n     |\n2569 |     assert_eq!(perl_expr.kind(), &HirKind::Class(Hir::class(hir::Class::Bytes(_))));\n     |                                                                               ^ `_` not allowed here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let flags = Flags {",
                "        case_insensitive: Some(false),",
                "        multi_line: Some(false),",
                "        dot_matches_new_line: Some(false),",
                "        swap_greed: Some(false),",
                "        unicode: Some(true),",
                "    };",
                "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                "    let unicode_class = ast::ClassUnicode {",
                "        span,",
                "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                "        negated: false,",
                "    };",
                "    let ast = Ast::Flags(ast_flags);",
                "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    visitor.visit_post(&ast).unwrap();",
                "    visitor.visit_post(&unicode_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Unicode(_)));"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.stack.borrow().is_empty());"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().flags.get().unicode().is_true());"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().allow_invalid_utf8.is_false());"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.visit_post(&unicode_ast).is_ok());"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.pop().is_none());"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.trans().flags.get().unicode(), true);"
                ],
                [
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl {",
                  "    span,",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    }));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Unicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().flags.get().unicode().is_true());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.trans().allow_invalid_utf8.is_false());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.visit_post(&unicode_ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.trans().flags.get().unicode(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(true),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::Named(\"Lu\"),",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let unicode_ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&unicode_ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(ast::Class::Perl(ast::ClassPerl {",
                  "    span,",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    }));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let expr = visitor.pop().unwrap().unwrap_expr();",
                  "    assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Unicode(_)));\n     |                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> regex-syntax/src/hir/translate.rs:2567:65\n     |\n2567 |     assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Unicode(_)));\n     |                                                                 ^ `_` not allowed here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2567:21\n     |\n2567 |     assert!(visitor.stack.borrow().is_empty());\n     |                     ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2567 |     assert!(visitor.trans.stack.borrow().is_empty());\n     |                     ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `is_true` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:51\n     |\n2567 |     assert!(visitor.trans().flags.get().unicode().is_true());\n     |                                                   ^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0599]: no method named `is_false` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:48\n     |\n2567 |     assert!(visitor.trans().allow_invalid_utf8.is_false());\n     |                                                ^^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:26\n     |\n2567 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:26\n     |\n2567 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:30\n     |\n2576 |     assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(_)));\n     |                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> regex-syntax/src/hir/translate.rs:2576:63\n     |\n2576 |     assert_eq!(expr.kind(), &HirKind::Class(hir::Class::Bytes(_)));\n     |                                                               ^ `_` not allowed here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2548:40\n     |\n2548 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Lu\"),\n     |               ---------------------------- ^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2554:26\n     |\n2554 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:26\n     |\n2567 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let flags = Flags {",
                "        case_insensitive: Some(false),",
                "        multi_line: Some(false),",
                "        dot_matches_new_line: Some(false),",
                "        swap_greed: Some(false),",
                "        unicode: Some(false),",
                "    };",
                "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                "    let empty_class = ast::ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ast::ClassSet::Union(vec![]),",
                "    };",
                "    let ast = Ast::Flags(ast_flags);",
                "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    visitor.visit_post(&ast).unwrap();",
                "    visitor.visit_post(&bracketed_ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let empty_class = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![]),",
                  "    };",
                  "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.visit_post(&bracketed_ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let empty_class = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![]),",
                  "    };",
                  "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.visit_post(&bracketed_ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::EmptyClassNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let empty_class = ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(vec![]),",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&bracketed_ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let empty_class = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![]),",
                  "    };",
                  "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.visit_post(&bracketed_ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "        case_insensitive: Some(false),",
                  "        multi_line: Some(false),",
                  "        dot_matches_new_line: Some(false),",
                  "        swap_greed: Some(false),",
                  "        unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let empty_class = ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Union(vec![]),",
                  "    };",
                  "    let ast = Ast::Flags(ast_flags);",
                  "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    visitor.visit_post(&bracketed_ast).unwrap();",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let flags = Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    };",
                  "    let ast_flags = ast::Flags { span, flags: flags.clone() };",
                  "    let empty_class = ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ast::ClassSet::Union(vec![]),",
                  "    };",
                  "    let bracketed_ast = Ast::Class(ast::Class::Bracketed(empty_class));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let result = visitor.visit_post(&bracketed_ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::EmptyClassNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:30\n     |\n2541 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:38\n     |\n2541 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2549:40\n     |\n2549 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |         kind: ast::ClassSet::Union(vec![]),\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n2553 |         kind: ast::ClassSet::union(vec![]),\n     |                              ~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2575:40\n     |\n2575 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:26\n     |\n2579 |     kind: ast::ClassSet::Union(vec![]),\n     |                          ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n2579 |     kind: ast::ClassSet::union(vec![]),\n     |                          ~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:30\n     |\n2541 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2541:38\n     |\n2541 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2549:40\n     |\n2549 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:30\n     |\n2553 |         kind: ast::ClassSet::Union(vec![]),\n     |                              ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n2553 |         kind: ast::ClassSet::union(vec![]),\n     |                              ~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:26\n     |\n2555 |     let ast = Ast::Flags(ast_flags);\n     |               ---------- ^^^^^^^^^ expected `SetFlags`, found `Flags`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:482:5\n     |\n482  |     Flags(SetFlags),\n     |     ^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0560]: struct `ast::Flags` has no field named `flags`\n    --> regex-syntax/src/hir/translate.rs:2575:40\n     |\n2575 |     let ast_flags = ast::Flags { span, flags: flags.clone() };\n     |                                        ^^^^^ `ast::Flags` does not have this field\n     |\n     = note: available fields are: `items`\n\nerror[E0599]: no variant or associated item named `Union` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:26\n     |\n2579 |     kind: ast::ClassSet::Union(vec![]),\n     |                          ^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Union` not found for this enum\n     |\nnote: if you're trying to build a new `ClassSet`, consider using `ClassSet::union` which returns `ClassSet`\n    --> regex-syntax/src/ast/mod.rs:940:5\n     |\n940  |     pub fn union(ast: ClassSetUnion) -> ClassSet {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: there is an associated function `union` with a similar name (notice the capitalization difference)\n     |\n2579 |     kind: ast::ClassSet::union(vec![]),\n     |                          ~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0560, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 18,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Empty(_) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) is true\n",
        "// constraint: self.hir_unicode_class(x)? is Err/None\n"
      ],
      "input_infer": "0 <= *ast category <= 1, 0 <= span.start <= 255, 0 <= span.end <= 255, 0 <= unicode property name length <= 100, 0 <= unicode property value length <= 100, 0 <= negation count <= 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 0 };",
                "    let ast = Ast::Empty(span);",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let ast = Ast::Empty(span);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     assert_eq!(translator_i.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);\n     |                                                                   ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let class_unicode = ClassUnicode {",
                "        span,",
                "        negated: false,",
                "        kind: ClassUnicodeKind::NamedValue {",
                "            name: \"property_name\".to_string(),",
                "            value: \"property_value\".to_string(),",
                "        },",
                "    };",
                "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let result = translator_i.visit_post(&ast);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    name: \"property_name\".to_string(),",
                  "    value: \"property_value\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    name: \"property_name\".to_string(),",
                  "    value: \"property_value\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(span);",
                  "    let result_empty = translator_i.visit_post(&ast_empty);",
                  "    assert!(result_empty.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    name: \"property_name\".to_string(),",
                  "    value: \"property_value\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(span);",
                  "    let result_empty = translator_i.visit_post(&ast_empty);",
                  "    let class_unicode_invalid = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::Named {",
                  "    name: \"invalid_property\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast_invalid = Ast::Class(ast::Class::Unicode(class_unicode_invalid));",
                  "    let result_invalid = translator_i.visit_post(&ast_invalid);",
                  "    assert!(result_invalid.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            name: \"property_name\".to_string(),",
                  "            value: \"property_value\".to_string(),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    name: \"property_name\".to_string(),",
                  "    value: \"property_value\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            name: \"property_name\".to_string(),",
                  "            value: \"property_value\".to_string(),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    name: \"property_name\".to_string(),",
                  "    value: \"property_value\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(span);",
                  "    let result_empty = translator_i.visit_post(&ast_empty);",
                  "    assert!(result_empty.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            name: \"property_name\".to_string(),",
                  "            value: \"property_value\".to_string(),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    name: \"property_name\".to_string(),",
                  "    value: \"property_value\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(span);",
                  "    let result_empty = translator_i.visit_post(&ast_empty);",
                  "    let class_unicode_invalid = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::Named {",
                  "    name: \"invalid_property\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast_invalid = Ast::Class(ast::Class::Unicode(class_unicode_invalid));",
                  "    let result_invalid = translator_i.visit_post(&ast_invalid);",
                  "    assert!(result_invalid.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:25\n     |\n2541 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassUnicodeKind::NamedValue {\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:25\n     |\n2559 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassUnicodeKind::NamedValue {\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:25\n     |\n2541 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassUnicodeKind::NamedValue {\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:25\n     |\n2559 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassUnicodeKind::NamedValue {\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:25\n     |\n2541 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassUnicodeKind::NamedValue {\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:25\n     |\n2559 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2562:11\n     |\n2562 |     kind: ClassUnicodeKind::NamedValue {\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     let class_unicode_invalid = ClassUnicode {\n     |                                 ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2580:11\n     |\n2580 |     kind: ClassUnicodeKind::Named {\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:38\n     |\n2558 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let perl_class = ClassPerl {",
                "        span,",
                "        kind: ClassPerlKind::Word,",
                "        negated: false,",
                "    };",
                "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    translator_i.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ErrorKind::UnicodeNotAllowed);"
                ],
                [
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.pattern, \"\");"
                ],
                [
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let perl_class = ClassPerl {",
                  "        span,",
                  "        kind: ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let perl_class = ClassPerl {",
                  "        span,",
                  "        kind: ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let perl_class = ClassPerl {",
                  "        span,",
                  "        kind: ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.pattern, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let perl_class = ClassPerl {",
                  "        span,",
                  "        kind: ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    translator_i.visit_post(&ast).unwrap();",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error.span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:22\n     |\n2541 |     let perl_class = ClassPerl {\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |         kind: ClassPerlKind::Word,\n     |               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:22\n     |\n2541 |     let perl_class = ClassPerl {\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |         kind: ClassPerlKind::Word,\n     |               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:22\n     |\n2541 |     let perl_class = ClassPerl {\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |         kind: ClassPerlKind::Word,\n     |               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:22\n     |\n2541 |     let perl_class = ClassPerl {\n     |                      ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::ClassPerl;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |         kind: ClassPerlKind::Word,\n     |               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassPerlKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 5 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 1, end: 2 };",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Normal,",
                "    };",
                "    let ast = Ast::Class(ast::Class::Bracketed(class_bracketed));",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let result = translator_i.visit_post(&ast);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 1, end: 2 };",
                "    let class_unicode = ClassUnicode {",
                "        span,",
                "        negated: true,",
                "        kind: ClassUnicodeKind::Named {",
                "            name: \"some_unicode_property\".to_string(),",
                "        },",
                "    };",
                "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                "    let result = translator_i.visit_post(&ast);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 1, end: 2 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::Named {",
                  "    name: \"some_unicode_property\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 1, end: 2 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::Named {",
                  "    name: \"some_unicode_property\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.err().unwrap();",
                  "    assert_eq!(error.kind, ErrorKind::UnicodePropertyNotFound);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let class_unicode = ClassUnicode {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassUnicodeKind::Named {",
                  "            name: \"some_unicode_property\".to_string(),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::Named {",
                  "    name: \"some_unicode_property\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let class_unicode = ClassUnicode {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassUnicodeKind::Named {",
                  "            name: \"some_unicode_property\".to_string(),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 1, end: 2 };",
                  "    let class_unicode = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::Named {",
                  "    name: \"some_unicode_property\".to_string(),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(class_unicode));",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.visit_post(&ast);",
                  "    let error = result.err().unwrap();",
                  "    assert_eq!(error.kind, ErrorKind::UnicodePropertyNotFound);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:25\n     |\n2541 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassUnicodeKind::Named {\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:25\n     |\n2558 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2561:11\n     |\n2561 |     kind: ClassUnicodeKind::Named {\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:38\n     |\n2557 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:25\n     |\n2541 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |         kind: ClassUnicodeKind::Named {\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:25\n     |\n2558 |     let class_unicode = ClassUnicode {\n     |                         ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2561:11\n     |\n2561 |     kind: ClassUnicodeKind::Named {\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: 1, end: 2 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:38\n     |\n2557 |     let span = Span { start: 1, end: 2 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 19,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) or Ast::Class(ast::Class::Perl(ref x)) or Ast::Class(ast::Class::Bracketed(ref ast)) is true\n",
        "// constraint: *ast matches Ast::Empty(_) is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Unicode(ref x)) is true\n",
        "// constraint: self.hir_unicode_class(x)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= x <= 0, valid Unicode class input; 0 <= x <= 15, non-empty Unicode class with valid ranges; 1 <= x <= 10, valid Perl class input; 0 <= x <= 0, empty input for Ast::Empty(_).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert!(matches!(visitor.pop().unwrap(), HirFrame::Expr(hir) if hir.kind() == &HirKind::Empty));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Empty(Span { start: 0, end: 0 });",
                  "    assert!(matches!(visitor.pop().unwrap(), HirFrame::Expr(hir) if hir.kind() == &HirKind::Empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:40\n     |\n2547 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:40\n     |\n2556 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:48\n     |\n2556 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:51\n     |\n2557 |     assert_eq!(visitor.visit_post(&ast).unwrap(), Ok(()));\n     |                                                   ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:40\n     |\n2547 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:40\n     |\n2556 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:48\n     |\n2556 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2557:84\n     |\n2557 |     assert!(matches!(visitor.pop().unwrap(), HirFrame::Expr(hir) if hir.kind() == &HirKind::Empty));\n     |                                                                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:40\n     |\n2547 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:48\n     |\n2547 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:40\n     |\n2556 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:48\n     |\n2556 |     let ast = Ast::Empty(Span { start: 0, end: 0 });\n     |                                                ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"\\\\p{L}\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let unicode_class = ast::ClassUnicode {",
                "        span: Span { start: 0, end: 5 },",
                "        negated: false,",
                "        kind: ast::ClassUnicodeKind::OneLetter('L'),",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: 0, end: 5 },",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: 0, end: 5 },",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: 0, end: 5 },",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    assert_matches!(frame, HirFrame::Expr(hir) if !hir.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: 0, end: 5 },",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: 0, end: 5 },",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\p{L}\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: 0, end: 5 },",
                  "    negated: false,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
                  "    };",
                  "    let ast = Ast::Class(ast::Class::Unicode(unicode_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    assert_matches!(frame, HirFrame::Expr(hir) if !hir.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:25\n     |\n2564 |     span: Span { start: 0, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:33\n     |\n2564 |     span: Span { start: 0, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:25\n     |\n2564 |     span: Span { start: 0, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:33\n     |\n2564 |     span: Span { start: 0, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2570:24\n     |\n2570 |     assert_eq!(visitor.stack.borrow().len(), 1);\n     |                        ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2570 |     assert_eq!(visitor.trans.stack.borrow().len(), 1);\n     |                        ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: cannot find macro `assert_matches` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:5\n     |\n2571 |     assert_matches!(frame, HirFrame::Expr(hir) if !hir.is_empty());\n     |     ^^^^^^^^^^^^^^\n     |\nhelp: consider importing this macro\n     |\n2535 +    use std::assert_matches::assert_matches;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:25\n     |\n2564 |     span: Span { start: 0, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:33\n     |\n2564 |     span: Span { start: 0, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"\\\\d\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let perl_class = ast::ClassPerl {",
                "        span: Span { start: 0, end: 3 },",
                "        kind: ast::ClassPerlKind::Digit,",
                "        negated: false,",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    assert_eq!(stack_length, 1);"
                ],
                [
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    assert!(matches!(hir.kind(), HirKind::Class(_)));"
                ],
                [
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    }",
                  "    _ => panic!(\"Expected HirFrame::Expr\");",
                  "    }",
                  "    let h_class = if let HirFrame::Expr(hir) = top_frame { hir.into_kind() } else { panic!() };",
                  "    assert!(matches!(h_class, HirKind::Class(Class::Perl(_))));"
                ],
                [
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    }",
                  "    _ => panic!(\"Expected HirFrame::Expr\");",
                  "    }",
                  "    let h_class = if let HirFrame::Expr(hir) = top_frame { hir.into_kind() } else { panic!() };",
                  "    assert!(visitor.flags().unicode());"
                ],
                [
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    }",
                  "    _ => panic!(\"Expected HirFrame::Expr\");",
                  "    }",
                  "    let h_class = if let HirFrame::Expr(hir) = top_frame { hir.into_kind() } else { panic!() };",
                  "    assert!(visitor.flags().case_insensitive().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\d\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: Span { start: 0, end: 3 },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    assert_eq!(stack_length, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\d\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: Span { start: 0, end: 3 },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    assert!(matches!(hir.kind(), HirKind::Class(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\d\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: Span { start: 0, end: 3 },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    }",
                  "    _ => panic!(\"Expected HirFrame::Expr\");",
                  "    }",
                  "    let h_class = if let HirFrame::Expr(hir) = top_frame { hir.into_kind() } else { panic!() };",
                  "    assert!(matches!(h_class, HirKind::Class(Class::Perl(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\d\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: Span { start: 0, end: 3 },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    }",
                  "    _ => panic!(\"Expected HirFrame::Expr\");",
                  "    }",
                  "    let h_class = if let HirFrame::Expr(hir) = top_frame { hir.into_kind() } else { panic!() };",
                  "    assert!(visitor.flags().unicode());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"\\\\d\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: Span { start: 0, end: 3 },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Perl(perl_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let mut stack_length = visitor.trans().stack.borrow().len();",
                  "    let top_frame = visitor.pop().unwrap();",
                  "    match top_frame {",
                  "    HirFrame::Expr(hir) => {",
                  "    }",
                  "    _ => panic!(\"Expected HirFrame::Expr\");",
                  "    }",
                  "    let h_class = if let HirFrame::Expr(hir) = top_frame { hir.into_kind() } else { panic!() };",
                  "    assert!(visitor.flags().case_insensitive().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2562:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2559 |     HirFrame::Expr(hir) => {\n     |                            - this delimiter might not be properly closed...\n2560 |     assert!(matches!(hir.kind(), HirKind::Class(_)));\n2561 | }\n     | - ...as it matches this but it has different indentation\n2562 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: `match` arm body without braces\n    --> regex-syntax/src/hir/translate.rs:2561:10\n     |\n2561 |     _ => panic!(\"Expected HirFrame::Expr\");\n     |       -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this statement is not surrounded by a body\n     |       |\n     |       while parsing the `match` arm starting here\n     |\nhelp: replace `;` with `,` to end a `match` arm expression\n     |\n2561 |     _ => panic!(\"Expected HirFrame::Expr\"),\n     |                                           ~\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:31\n     |\n2564 |     assert!(matches!(h_class, HirKind::Class(Class::Perl(_))));\n     |                               ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n    --> regex-syntax/src/hir/translate.rs:2564:46\n     |\n2564 |     assert!(matches!(h_class, HirKind::Class(Class::Perl(_))));\n     |                                              ^^^^^ use of undeclared type `Class`\n     |\nhelp: consider importing one of these enums\n     |\n2535 +    use ast::Class;\n     |\n2535 +    use hir::Class;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: `match` arm body without braces\n    --> regex-syntax/src/hir/translate.rs:2561:10\n     |\n2561 |     _ => panic!(\"Expected HirFrame::Expr\");\n     |       -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this statement is not surrounded by a body\n     |       |\n     |       while parsing the `match` arm starting here\n     |\nhelp: replace `;` with `,` to end a `match` arm expression\n     |\n2561 |     _ => panic!(\"Expected HirFrame::Expr\"),\n     |                                           ~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: `match` arm body without braces\n    --> regex-syntax/src/hir/translate.rs:2561:10\n     |\n2561 |     _ => panic!(\"Expected HirFrame::Expr\");\n     |       -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this statement is not surrounded by a body\n     |       |\n     |       while parsing the `match` arm starting here\n     |\nhelp: replace `;` with `,` to end a `match` arm expression\n     |\n2561 |     _ => panic!(\"Expected HirFrame::Expr\"),\n     |                                           ~\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no method named `is_none` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:48\n     |\n2564 |     assert!(visitor.flags().case_insensitive().is_none());\n     |                                                ^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"[a-z]\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let bracketed_class = ast::ClassBracketed {",
                "        span: Span { start: 0, end: 5 },",
                "        negated: false,",
                "        kind: ast::ClassSet::Normal,",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(matches!(trans.stack.borrow()[0], HirFrame::Expr(_)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.flags().unicode());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(trans.flags.get().unicode());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(trans.stack.borrow().last().unwrap().unwrap_expr().kind().is_empty() == false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let bracketed_class = ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let bracketed_class = ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(matches!(trans.stack.borrow()[0], HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let bracketed_class = ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.flags().unicode());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let bracketed_class = ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(trans.flags.get().unicode());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let bracketed_class = ast::ClassBracketed {",
                  "        span: Span { start: 0, end: 5 },",
                  "        negated: false,",
                  "        kind: ast::ClassSet::Normal,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"[a-z]\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };",
                  "    let ast = Ast::Class(ast::Class::Bracketed(bracketed_class));",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(trans.stack.borrow().last().unwrap().unwrap_expr().kind().is_empty() == false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:30\n     |\n2551 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:119\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                                                                       ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:30\n     |\n2551 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:119\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                                                                       ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:30\n     |\n2551 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:119\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                                                                       ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:30\n     |\n2551 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:119\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                                                                       ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:29\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:37\n     |\n2549 |         span: Span { start: 0, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:30\n     |\n2551 |         kind: ast::ClassSet::Normal,\n     |                              ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Normal` found for enum `ClassSet` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:119\n     |\n2559 |     let bracketed_class = ast::ClassBracketed { span: Span { start: 0, end: 5 }, negated: false, kind: ast::ClassSet::Normal };\n     |                                                                                                                       ^^^^^^ variant or associated item not found in `ClassSet`\n     |\n    ::: regex-syntax/src/ast/mod.rs:930:1\n     |\n930  | pub enum ClassSet {\n     | ----------------- variant or associated item `Normal` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 20,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Assertion(ref x) is true\n",
        "// constraint: *ast matches Ast::Assertion(ref x) is true\n",
        "// constraint: self.hir_assertion(x)? is Err/None\n"
      ],
      "input_infer": "char: '\\u{0}' to '\\u{10FFFF}', flags: { case_insensitive: false, multi_line: true, dot_matches_new_line: false }, pattern: \"AssertionTest\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: Some(true),",
                "            dot_matches_new_line: Some(false),",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let pattern = \"AssertionTest\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span {",
                "        start: Position(0),",
                "        end: Position(1),",
                "    };",
                "    ",
                "    let assertion = Assertion {",
                "        span,",
                "        kind: AssertionKind::StartLine,",
                "    };",
                "    ",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let result = translator.visit_post(&ast);",
                "    // No assertions are made here as per the instruction",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::StartLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::StartLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::Parse(_));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::StartLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::StartLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::Parse(_));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::StartLine,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2586:21\n     |\n2586 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2588:11\n     |\n2588 |     kind: AssertionKind::StartLine,\n     |           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:12\n     |\n2583 |     start: Position(0),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:10\n     |\n2584 |     end: Position(1),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::StartLine,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2586:21\n     |\n2586 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2588:11\n     |\n2588 |     kind: AssertionKind::StartLine,\n     |           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n    --> regex-syntax/src/hir/translate.rs:2592:59\n     |\n2592 |     assert_eq!(result.unwrap_err().kind, ErrorKind::Parse(_));\n     |                                                           ^ `_` not allowed here\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:12\n     |\n2583 |     start: Position(0),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:10\n     |\n2584 |     end: Position(1),\n     |          ^^^^^^^^ not found in this scope\n\nerror[E0599]: no variant or associated item named `Parse` found for enum `hir::ErrorKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2592:53\n     |\n2592 |     assert_eq!(result.unwrap_err().kind, ErrorKind::Parse(_));\n     |                                                     ^^^^^ variant or associated item not found in `ErrorKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:65:1\n     |\n65   | pub enum ErrorKind {\n     | ------------------ variant or associated item `Parse` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: Some(true),",
                "            dot_matches_new_line: Some(false),",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    ",
                "    let pattern = \"AssertionTest\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span {",
                "        start: Position(0),",
                "        end: Position(1),",
                "    };",
                "    ",
                "    let assertion = Assertion {",
                "        span,",
                "        kind: AssertionKind::EndLine,",
                "    };",
                "    ",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let result = translator.visit_post(&ast);",
                "    // No assertions are made here as per the instruction",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::EndLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.is_err(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::EndLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyValueNotFound);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::EndLine,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::EndLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::EndLine,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(true),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let assertion = Assertion {",
                  "    span,",
                  "    kind: AssertionKind::EndLine,",
                  "    };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyValueNotFound);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::EndLine,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2586:21\n     |\n2586 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2588:11\n     |\n2588 |     kind: AssertionKind::EndLine,\n     |           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:12\n     |\n2583 |     start: Position(0),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:10\n     |\n2584 |     end: Position(1),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::EndLine,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2586:21\n     |\n2586 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2588:11\n     |\n2588 |     kind: AssertionKind::EndLine,\n     |           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:12\n     |\n2583 |     start: Position(0),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:10\n     |\n2584 |     end: Position(1),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: Some(true),",
                "            dot_matches_new_line: Some(false),",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    ",
                "    let pattern = \"AssertionTest\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span {",
                "        start: Position(0),",
                "        end: Position(1),",
                "    };",
                "    ",
                "    let assertion = Assertion {",
                "        span,",
                "        kind: AssertionKind::WordBoundary,",
                "    };",
                "    ",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let result = translator.visit_post(&ast);",
                "    // No assertions are made here as per the instruction",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodeNotAllowed);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(translator.pop().is_some(), true);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(translator.stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(translator.trans().flags.get().multi_line.unwrap(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(translator.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(translator.stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let assertion = Assertion {",
                  "        span,",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: Some(false), multi_line: Some(true), dot_matches_new_line: Some(false), swap_greed: None, unicode: Some(true), }), allow_invalid_utf8: true, };",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(0), end: Position(1), };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(translator.trans().flags.get().multi_line.unwrap(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::WordBoundary,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:21\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2573:45\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:30\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:48\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::WordBoundary,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:21\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2573:45\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:30\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:48\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::WordBoundary,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:21\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2573:45\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:30\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:48\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::WordBoundary,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:21\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2573:45\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:30\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:48\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2576:27\n     |\n2576 |     assert_eq!(translator.stack.borrow().len(), 0);\n     |                           ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2576 |     assert_eq!(translator.trans.stack.borrow().len(), 0);\n     |                           ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:21\n     |\n2560 |     let assertion = Assertion {\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2562:15\n     |\n2562 |         kind: AssertionKind::WordBoundary,\n     |               ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:21\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2573:45\n     |\n2573 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary, };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:30\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:48\n     |\n2572 |     let span = Span { start: Position(0), end: Position(1), };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: Some(true),",
                "            dot_matches_new_line: Some(false),",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    ",
                "    let pattern = \"AssertionTest\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    ",
                "    let span = Span {",
                "        start: Position(0),",
                "        end: Position(1),",
                "    };",
                "    ",
                "    let class = ClassUnicode {",
                "        span,",
                "        negated: true,",
                "        kind: ClassUnicodeKind::OneLetter('a'),",
                "    };",
                "    ",
                "    let ast = Ast::Class(ast::Class::Unicode(class));",
                "    ",
                "    let result = translator.visit_post(&ast);",
                "    // No assertions are made here as per the instruction",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let class = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Assertion(Assertion {",
                  "    span: span.clone(),",
                  "    kind: AssertionKind::StartText,",
                  "    });",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let class = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Assertion(Assertion {",
                  "    span: span.clone(),",
                  "    kind: AssertionKind::StartText,",
                  "    });",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyNotFound);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let class = ClassUnicode {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(class));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let class = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Assertion(Assertion {",
                  "    span: span.clone(),",
                  "    kind: AssertionKind::StartText,",
                  "    });",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    ",
                  "    let pattern = \"AssertionTest\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    ",
                  "    let span = Span {",
                  "        start: Position(0),",
                  "        end: Position(1),",
                  "    };",
                  "    ",
                  "    let class = ClassUnicode {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    ",
                  "    let ast = Ast::Class(ast::Class::Unicode(class));",
                  "    ",
                  "    let result = translator.visit_post(&ast);",
                  "    // No assertions are made here as per the instruction",
                  "    let translator = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(0),",
                  "    end: Position(1),",
                  "    };",
                  "    let class = ClassUnicode {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Assertion(Assertion {",
                  "    span: span.clone(),",
                  "    kind: AssertionKind::StartText,",
                  "    });",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyNotFound);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:17\n     |\n2560 |     let class = ClassUnicode {\n     |                 ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2575:17\n     |\n2575 |     let class = ClassUnicode {\n     |                 ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2578:11\n     |\n2578 |     kind: ClassUnicodeKind::OneLetter('a'),\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:30\n     |\n2580 |     let ast = Ast::Assertion(Assertion {\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: AssertionKind::StartText,\n     |           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:12\n     |\n2572 |     start: Position(0),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:10\n     |\n2573 |     end: Position(1),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:17\n     |\n2560 |     let class = ClassUnicode {\n     |                 ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassUnicodeKind::OneLetter('a'),\n     |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n    --> regex-syntax/src/hir/translate.rs:2575:17\n     |\n2575 |     let class = ClassUnicode {\n     |                 ^^^^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n2535 +    use hir::translate::HirFrame::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2578:11\n     |\n2578 |     kind: ClassUnicodeKind::OneLetter('a'),\n     |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassUnicodeKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2580:30\n     |\n2580 |     let ast = Ast::Assertion(Assertion {\n     |                              ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2582:11\n     |\n2582 |     kind: AssertionKind::StartText,\n     |           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(0),\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(1),\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2572:12\n     |\n2572 |     start: Position(0),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:10\n     |\n2573 |     end: Position(1),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 21,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Assertion(ref x) is true\n",
        "// constraint: *ast matches Ast::Assertion(ref x) is true\n",
        "// constraint: self.hir_assertion(x)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= *x <= 10, self.flags().unicode() == true, self.flags().multi_line() == true, ast.span.start >= 0, ast.span.end <= 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        multi_line: Some(true),",
                "        ..Default::default()",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Anchor(hir::Anchor::WordBoundary));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.stack.borrow().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Anchor(hir::Anchor::WordBoundary));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.stack.borrow().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2573:62\n     |\n2573 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Anchor(hir::Anchor::WordBoundary));\n     |                                                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no variant or associated item named `WordBoundary` found for enum `Anchor` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2573:91\n     |\n2573 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Anchor(hir::Anchor::WordBoundary));\n     |                                                                                           ^^^^^^^^^^^^ variant or associated item not found in `Anchor`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1101:1\n     |\n1101 | pub enum Anchor {\n     | --------------- variant or associated item `WordBoundary` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::WordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `stack` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2573:21\n     |\n2573 |     assert!(visitor.stack.borrow().is_empty());\n     |                     ^^^^^ unknown field\n     |\nhelp: one of the expressions' fields has a field of the same name\n     |\n2573 |     assert!(visitor.trans.stack.borrow().is_empty());\n     |                     ++++++\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        multi_line: Some(true),",
                "        ..Default::default()",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.flags().multi_line, Some(true));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.flags().unicode, Some(true));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.flags().multi_line, Some(true));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.flags().unicode, Some(true));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::StartText };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        multi_line: Some(true),",
                "        ..Default::default()",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let hir_frame = visitor.trans().stack.borrow().last().unwrap();",
                  "    if let HirFrame::Expr(hir) = hir_frame {",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let hir_frame = visitor.trans().stack.borrow().last().unwrap();",
                  "    if let HirFrame::Expr(hir) = hir_frame {",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::EndLine };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::EndLine };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::EndLine };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::EndLine };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2577:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2577 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                "    let ast = Ast::Assertion(assertion);",
                "    ",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        multi_line: Some(true),",
                "        ..Default::default()",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                "    ",
                "    visitor.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(matches!(visitor.trans().stack.borrow()[0], HirFrame::Expr(_)));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(matches!(visitor.trans().stack.borrow()[0], HirFrame::Expr(expr) if expr.kind() == &HirKind::Anchor(hir::Anchor::WordBoundary)));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(visitor.flags().unicode().is_some());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(visitor.flags().multi_line().is_some());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(visitor.flags().case_insensitive().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(matches!(visitor.trans().stack.borrow()[0], HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(matches!(visitor.trans().stack.borrow()[0], HirFrame::Expr(expr) if expr.kind() == &HirKind::Anchor(hir::Anchor::WordBoundary)));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(visitor.flags().unicode().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(visitor.flags().multi_line().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        multi_line: Some(true),",
                  "        ..Default::default()",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test pattern\");",
                  "    ",
                  "    visitor.visit_post(&ast).unwrap();",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert!(visitor.flags().case_insensitive().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2561:97\n     |\n2561 | ...()[0], HirFrame::Expr(expr) if expr.kind() == &HirKind::Anchor(hir::Anchor::WordBoundary)));\n     |                                                   ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no variant or associated item named `WordBoundary` found for enum `Anchor` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:126\n     |\n2561 | ...() == &HirKind::Anchor(hir::Anchor::WordBoundary)));\n     |                                        ^^^^^^^^^^^^ variant or associated item not found in `Anchor`\n     |\n    ::: regex-syntax/src/hir/mod.rs:1101:1\n     |\n1101 | pub enum Anchor {\n     | --------------- variant or associated item `WordBoundary` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_some` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:39\n     |\n2561 |     assert!(visitor.flags().unicode().is_some());\n     |                                       ^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_some` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:42\n     |\n2561 |     assert!(visitor.flags().multi_line().is_some());\n     |                                          ^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2541:21\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2541:45\n     |\n2541 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:21\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                     ^^^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::Assertion;\n     |\n2535 +    use hir::translate::Ast::Assertion;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n    --> regex-syntax/src/hir/translate.rs:2559:45\n     |\n2559 |     let assertion = Assertion { span, kind: AssertionKind::NotWordBoundary };\n     |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::AssertionKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_none` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     assert!(visitor.flags().case_insensitive().is_none());\n     |                                                ^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 22,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Dot(span) is true\n",
        "// constraint: *ast matches Ast::Dot(span) is true\n",
        "// constraint: self.hir_dot(span)? is Err/None\n"
      ],
      "input_infer": "span: (0, 0) to (5, 5)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \".\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                "    let _ = visitor.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 0 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:38\n     |\n2556 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:46\n     |\n2556 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:38\n     |\n2556 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:46\n     |\n2556 |     let ast = Ast::Dot(Span { start: 0, end: 0 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \".\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                "    let _ = visitor.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert!(matches!(visitor.pop(), Some(HirFrame::Expr(hir))));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert_eq!(visitor.pop().is_none(), true);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert!(matches!(visitor.visit_post(&ast), Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert!(matches!(visitor.pop(), Some(HirFrame::Expr(hir))));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert_eq!(visitor.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 1, end: 1 });",
                  "    assert!(matches!(visitor.visit_post(&ast), Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:46\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:46\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:46\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:46\n     |\n2552 |     let ast = Ast::Dot(Span { start: 1, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \".\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                "    let _ = visitor.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 5, end: 5 });",
                  "    let result = visitor.visit_post(&ast);",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:38\n     |\n2556 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:46\n     |\n2556 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:38\n     |\n2547 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2547:46\n     |\n2547 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:38\n     |\n2556 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:46\n     |\n2556 |     let ast = Ast::Dot(Span { start: 5, end: 5 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false, // Setting this to false to trigger an error",
                "    };",
                "    let pattern = \".\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                "    let _ = visitor.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                  "    assert_eq!(visitor.pop().is_none(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                  "    assert!(matches!(visitor.visit_post(&ast), Err(Error { kind: ErrorKind::InvalidUtf8, .. })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false, // Setting this to false to trigger an error",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                  "    assert_eq!(visitor.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false, // Setting this to false to trigger an error",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                  "    let _ = visitor.visit_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let ast = Ast::Dot(Span { start: 0, end: 1 });",
                  "    assert!(matches!(visitor.visit_post(&ast), Err(Error { kind: ErrorKind::InvalidUtf8, .. })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:38\n     |\n2548 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:46\n     |\n2548 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:38\n     |\n2557 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:46\n     |\n2557 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:38\n     |\n2548 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:46\n     |\n2548 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:38\n     |\n2557 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:46\n     |\n2557 |     let ast = Ast::Dot(Span { start: 0, end: 1 });\n     |                                              ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 23,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Dot(span) is true\n",
        "// constraint: *ast matches Ast::Dot(span) is true\n",
        "// constraint: self.hir_dot(span)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "span: (0, 0) to (1, 1)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let ast = Ast::Dot(span);",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 0 };",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let ast = Ast::Dot(span);",
                "    translator.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.stack.borrow()[0], HirFrame::Expr(_)));"
                ],
                [
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.stack.borrow()[0].unwrap_expr().kind(), HirKind::Dot(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.stack.borrow()[0], HirFrame::Expr(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    let span = Span { start: 0, end: 0 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    translator.visit_post(&ast).unwrap();",
                  "    assert!(matches!(translator.stack.borrow()[0].unwrap_expr().kind(), HirKind::Dot(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2547 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:38\n     |\n2548 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2555 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2547 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:38\n     |\n2548 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2555 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2556:73\n     |\n2556 |     assert!(matches!(translator.stack.borrow()[0].unwrap_expr().kind(), HirKind::Dot(_)));\n     |                                                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2547 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let span = Span { start: 0, end: 0 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2548:38\n     |\n2548 |     let span = Span { start: 0, end: 0 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2555 |     translator.visit_post(&ast).unwrap();\n     |                ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let ast = Ast::Dot(span);",
                "    let result = translator.visit_post(&ast);",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    assert!(translator.visit_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = Ast::Dot(span);",
                  "    assert!(translator.visit_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2547 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:30\n     |\n2549 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2549:38\n     |\n2549 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2556 |     assert!(translator.visit_post(&ast).is_ok());\n     |                        ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 24,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: self.hir_literal(x)? is Err/None\n"
      ],
      "input_infer": "test input ranges: ast = Ast::Literal(x) where x is an invalid character that cannot be translated, causing self.hir_literal(x) to return Err/None due to invalid input cases, such as a non-Unicode character or an unsupported escape sequence.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let invalid_literal = ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Byte(b'\\xFF'), // Non-Unicode character",
                "        c: '\\u{FFFD}', // Replacement character",
                "    };",
                "    let ast = Ast::Literal(invalid_literal);",
                "    let result = translator.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };",
                  "    let ast = Ast::Literal(invalid_literal);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };",
                  "    let ast = Ast::Literal(invalid_literal);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let invalid_literal = ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Byte(b'\\xFF'), // Non-Unicode character",
                  "        c: '\\u{FFFD}', // Replacement character",
                  "    };",
                  "    let ast = Ast::Literal(invalid_literal);",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };",
                  "    let ast = Ast::Literal(invalid_literal);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let invalid_literal = ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Byte(b'\\xFF'), // Non-Unicode character",
                  "        c: '\\u{FFFD}', // Replacement character",
                  "    };",
                  "    let ast = Ast::Literal(invalid_literal);",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };",
                  "    let ast = Ast::Literal(invalid_literal);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Byte(b'\\xFF'), // Non-Unicode character\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2551 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:62\n     |\n2553 |     let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };\n     |                                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:70\n     |\n2553 |     let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };\n     |                                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:99\n     |\n2553 |     let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };\n     |                                                                                                   ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2555 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Byte(b'\\xFF'), // Non-Unicode character\n     |                                 ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2551 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:62\n     |\n2553 |     let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };\n     |                                                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:70\n     |\n2553 |     let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };\n     |                                                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:99\n     |\n2553 |     let invalid_literal = ast::Literal { span: Span { start: 0, end: 1 }, kind: ast::LiteralKind::Byte(b'\\xFF'), c: '\\u{FFFD}' };\n     |                                                                                                   ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2555 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let unsupported_escape = ast::Literal {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::LiteralKind::Escape(r\"\\xGG\"), // Invalid escape sequence",
                "        c: '\\u{FFFD}', // Replacement character for unsupported",
                "    };",
                "    let ast = Ast::Literal(unsupported_escape);",
                "    let result = translator.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let unsupported_escape = ast::Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::LiteralKind::Escape(r\"\\xGG\"),",
                  "    c: '\\u{FFFD}',",
                  "    };",
                  "    let ast = Ast::Literal(unsupported_escape);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let unsupported_escape = ast::Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::LiteralKind::Escape(r\"\\xGG\"),",
                  "    c: '\\u{FFFD}',",
                  "    };",
                  "    let ast = Ast::Literal(unsupported_escape);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyValueNotFound);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let unsupported_escape = ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Escape(r\"\\xGG\"), // Invalid escape sequence",
                  "        c: '\\u{FFFD}', // Replacement character for unsupported",
                  "    };",
                  "    let ast = Ast::Literal(unsupported_escape);",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let unsupported_escape = ast::Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::LiteralKind::Escape(r\"\\xGG\"),",
                  "    c: '\\u{FFFD}',",
                  "    };",
                  "    let ast = Ast::Literal(unsupported_escape);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let unsupported_escape = ast::Literal {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::LiteralKind::Escape(r\"\\xGG\"), // Invalid escape sequence",
                  "        c: '\\u{FFFD}', // Replacement character for unsupported",
                  "    };",
                  "    let ast = Ast::Literal(unsupported_escape);",
                  "    let result = translator.visit_post(&ast);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let unsupported_escape = ast::Literal {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::LiteralKind::Escape(r\"\\xGG\"),",
                  "    c: '\\u{FFFD}',",
                  "    };",
                  "    let ast = Ast::Literal(unsupported_escape);",
                  "    let result = translator.visit_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyValueNotFound);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Escape` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Escape(r\"\\xGG\"), // Invalid escape sequence\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Escape` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2551 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:25\n     |\n2558 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Escape` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |     kind: ast::LiteralKind::Escape(r\"\\xGG\"),\n     |                             ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Escape` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:37\n     |\n2546 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Escape` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |         kind: ast::LiteralKind::Escape(r\"\\xGG\"), // Invalid escape sequence\n     |                                 ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Escape` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2551 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:25\n     |\n2558 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Escape` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |     kind: ast::LiteralKind::Escape(r\"\\xGG\"),\n     |                             ^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Escape` not found for this enum\n\nerror[E0599]: no method named `visit_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_post` not found for this struct\n...\n2563 |     let result = translator.visit_post(&ast);\n     |                             ^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `visit_post`, perhaps you need to implement one of them:\n             candidate #1: `ast::visitor::Visitor`\n             candidate #2: `hir::visitor::Visitor`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 25,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: self.hir_literal(x)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= x <= 0x10FFFF\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                "    let ast_input = Ast::Literal(literal);",
                "    visitor.visit_post(&ast_input).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    assert!(expr.kind().is_literal());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    assert_eq!(expr.as_literal().unwrap().c, 'a');"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().case_insensitive.is_none());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().multi_line.is_none());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().dot_matches_new_line.is_none());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().swap_greed.is_none());"
                ],
                [
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().unicode.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    assert_eq!(stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    assert!(expr.kind().is_literal());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    assert_eq!(expr.as_literal().unwrap().c, 'a');",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().case_insensitive.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().multi_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().dot_matches_new_line.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().swap_greed.is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"a\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let mut stack = visitor.trans().stack.borrow_mut();",
                  "    let frame = stack.last().unwrap();",
                  "    match frame {",
                  "    HirFrame::Expr(expr) => {",
                  "    }",
                  "    _ => panic!(\"Expected expression frame, got: {:?}\", frame),",
                  "    }",
                  "    assert!(visitor.trans().flags.get().unicode.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2556:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2553 |     HirFrame::Expr(expr) => {\n     |                             - this delimiter might not be properly closed...\n2554 |     assert!(expr.kind().is_literal());\n2555 | }\n     | - ...as it matches this but it has different indentation\n2556 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2556:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2553 |     HirFrame::Expr(expr) => {\n     |                             - this delimiter might not be properly closed...\n2554 |     assert_eq!(expr.as_literal().unwrap().c, 'a');\n2555 | }\n     | - ...as it matches this but it has different indentation\n2556 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'a' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"\\u{10FFFF}\");",
                "    let span = Span { start: 0, end: 4 }; // assuming the byte length for 0x10FFFF",
                "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: '\\u{10FFFF}' };",
                "    let ast_input = Ast::Literal(literal);",
                "    visitor.visit_post(&ast_input).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let mut visitor = TranslatorI::new(&translator, \"\\u{10FFFF}\");",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: '\\u{10FFFF}' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Literal(Hir::literal(literal)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"\\u{10FFFF}\");",
                  "    let span = Span { start: 0, end: 4 }; // assuming the byte length for 0x10FFFF",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: '\\u{10FFFF}' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let mut visitor = TranslatorI::new(&translator, \"\\u{10FFFF}\");",
                  "    let span = Span { start: 0, end: 4 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: '\\u{10FFFF}' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    visitor.visit_post(&ast_input).unwrap();",
                  "    assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Literal(Hir::literal(literal)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2556:62\n     |\n2556 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Literal(Hir::literal(literal)));\n     |                                                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 4 }; // assuming the byte length for 0x10FFFF\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 4 }; // assuming the byte length for 0x10FFFF\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: '\\u{10FFFF}' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 4 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 4 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:64\n     |\n2553 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: '\\u{10FFFF}' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:92\n     |\n2556 |     assert_eq!(visitor.pop().unwrap().unwrap_expr().kind(), &HirKind::Literal(Hir::literal(literal)));\n     |                                                                               ------------ ^^^^^^^ expected `hir::Literal`, found `ast::Literal`\n     |                                                                               |\n     |                                                                               arguments to this function are incorrect\n     |\n     = note: `ast::Literal` and `hir::Literal` have similar names, but are actually distinct types\nnote: `ast::Literal` is defined in module `crate::ast` of the current crate\n    --> regex-syntax/src/ast/mod.rs:614:1\n     |\n614  | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: `hir::Literal` is defined in module `crate::hir` of the current crate\n    --> regex-syntax/src/hir/mod.rs:630:1\n     |\n630  | pub enum Literal {\n     | ^^^^^^^^^^^^^^^^\nnote: associated function defined here\n    --> regex-syntax/src/hir/mod.rs:239:12\n     |\n239  |     pub fn literal(lit: Literal) -> Hir {\n     |            ^^^^^^^ ------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false, // This should trigger a failure",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"b\");",
                "    let span = Span { start: 0, end: 1 };",
                "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'b' };",
                "    let ast_input = Ast::Literal(literal);",
                "    assert!(visitor.visit_post(&ast_input).is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut visitor = TranslatorI::new(&translator, \"b\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'b' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    assert_eq!(visitor.visit_post(&ast_input), Err(Error { kind: ErrorKind::InvalidUtf8, pattern: \"b\".to_string(), span }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false, // This should trigger a failure",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"b\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'b' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    assert!(visitor.visit_post(&ast_input).is_err());",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut visitor = TranslatorI::new(&translator, \"b\");",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'b' };",
                  "    let ast_input = Ast::Literal(literal);",
                  "    assert_eq!(visitor.visit_post(&ast_input), Err(Error { kind: ErrorKind::InvalidUtf8, pattern: \"b\".to_string(), span }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2546:38\n     |\n2546 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:64\n     |\n2547 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'b' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:64\n     |\n2553 |     let literal = ast::Literal { span, kind: ast::LiteralKind::Char, c: 'b' };\n     |                                                                ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}